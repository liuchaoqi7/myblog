<template>
  <div class="detail-javascript-height">
    <h1 class="title">JavaScript 高级程序设计</h1>
     <P>命名空间，疑问</P>
    <p>P30</p>
    <p>HTML是超文本标记语言，主要用来显示内容；XHTML:可扩展超文本标记语言，兼容HTML和XML；XML：可扩展标记语言，主要用于数据内容的传输，可以跨平台使用，是未来发展的趋势；</p>
    <h1>第一章：JavaScript 简介</h1>
    <p>由ECMA-262定义的ECMAScript与Web浏览器没有依赖关系。Web浏览器只是ECMAScript实现可能的宿主环境之一（像Node是服务器端的环境，也是一种宿主环境）。宿主环境不仅提供基本的ECMAScript实现，同时还会提供该语言的扩展，以便语言与环境之间对接交互。而这些扩展--如DOM，则是利用ECMAScript的核心类型和语法提供更多具体的功能，以便实现针对环境的操作。</p>
    <p>ECMA-262标准规定了这门语言这些部分：语法、类型、语句、关键字、保留字、操作符、对象；</p>
    <p>DOM1级由两个模块组成：DOM Core(DOM核心)和DOM HTML。DOM核心规定的是如何映射基于XML的文档结构，以便简化对文档中任意部分的访问和操作。DOM HTML模块则在DOM核心的基础上加以拓展，添加了对HTML的对象和方法。</p>
    <h1>第二章：在HTML中使用JavaScript</h1>
    <p>async:表示应该立即下载脚本，但不妨碍页面的其他操作，其目的是不让页面等待两个脚本下载和执行。</p>
    <p>defer:表示立即下载脚本，但可以延迟到文档完全被解析和显示完之后再执行。</p>
    <p>在使用&ltscript>嵌入代码时，记住不要在代码中的任何地方出现“&ltscript>”字符串，否则会被解释成结束标签，出现语法错误。</p>
    <p>与解析嵌入式JavaScript代码一样在解析外部JavaScript文件（包括下载该文件）时，页面的处理也会暂时停止。</p>
    <p>如果在XHTML文档中，也可以省略前面示例代码中的结束标签&ltscript>。但是这种语法不符合HTML规范。</p>
    <p>带有src属性的&ltscript>元素不应该在其&ltscript>和&lts/cript>标签之间再包含额外的JavaScript代码；如果嵌入了JavaScript代码，则只会下载并执行外部脚本文件，嵌入的代码会被忽略。</p>
    <p>文档模式：混杂模式和标准模式。HTML5的文档模式：&lt!DOCTYPE html></p>
    <h2>第三章：基本概念</h2>
    <p>ECMA-262通过叫做ECMAScript的“伪语言”为我们描述了JavaScript的所有这些基本概念。</p>
    <p>标识符：就是指变量、函数、属性名字，或者函数的参数。</p>
    <p>要在整个脚本中启用严格模式,可以在顶部添加如下代码："use strict";在函数内部的上方包含这条编译指示，也可以指定函数在严格模式下执行。严格模式为这门语言中容易出错的地方施加了限制；</p>
    <p>未经初始化的变量会保存一个特殊的值--undefined;</p>
    <p>ECMAScript中有5中简单的数据类型（也称基本数据类型）：Undefined、Null(可以看做是一个空对象)、Boolean、Number、String;还有一种复杂的数据类型：Object;</p>
    <p>typeof:是一个操作符而不是一个函数，所以括号原本是不须要的，但出于方便阅读代码，也可以使用；</p>
    <p>Undefined：在使用var声明变量但未对其加以初始化时的值；用于与空对象指针做对比；如果输出一个变量既没有定义声明也没有初始化则会产生报错；如果用操作符typeof检测未初始化的变量或者未声明的变量则会都显示undefined值；</p>
    <p>实际上，undefined值派生自null值的，因此ECMA-262规定对他们的相等性测试要返回true;</p>
    <p>虽然Boolean类型的字面量只有两个，<strong>但ECMAScript中所有类型的值都有与这两个Boolean值等价的值</strong>。要将一个值转换为其对应的Boolean值，可以调用转型函数Boolean();</p>
    <p>八进制字面量的第一位必须是0，然后是八进制数字序列（0-7），如果字面值中的数值超出了范围，那么前导0将会被忽略，后面的数值将被当做十进制数值解析。八进制字面量在严格模式下是无效的，会出现报错；十六进制字面值的前两位必须是0x,后跟任何十六进制数字（0-9及a-f不区分大小写）；在进行算数计算时，任何进制的数字都将被转换为十进制。</p>
    <p>虽然小数点前面可以没有整数，但是我们不推荐这种写法（.1）。</p>
    <p>由于存储小数需要的空间是存储整数的两倍，所以通常会自动把整数值的小数存储为整数。</p>
    <p>对于极大或极小的数值可以用e表示法（科学计数法）表示的浮点数值表示。浮点数值的最高精度是17位，但在进行算数计算时其精度远远不如整数。</p>
    <p>由于内存的限制，ECMAScript并不能保存世界上所有数值，最小值：5e-324；最大值1.79~e+308;如果某个数值超过了这个范围则会被转换为特殊的Infinity值，如果想要确定某个数值是否在最大值和最小值之间可以使用isFinite()来判断；</p>
    <p>NaN:即非数值是一个特殊的数值，这数值用于表示一个原本要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。一、任何涉及NaN的操作(NaN/10)都会返回NaN;二、NaN与任何人都不相等，包括其本身；想要检测某个参数是否“不是数值”可以用isNaN()函数来检测，此函数会把参数转换为数值，如果无法转换为数值则会返回true；</p>
    <p>把非数值转换为数值的函数：Number()可以用于任何数据类型；parseInt()、parseFloat()：专门用于把字符串转换为数值;</p>
    <p>Number()：</p>
    <p class="text_indent">如果是null,则返回0；</p>
    <p class="text_indent">如果是undefined,返回NaN;</p>
    <p class="text_indent">如果是字符串，遵循下列规则;</p>
    <p class="text_indent2">如果是字符串中只包含数字则将其转换为十进制数值，“011”会变成11，前导零被忽略；</p>
    <p class="text_indent2">如果字符串中包含有效的十六进制格式，“0xf”会被转换成相同大小的十进制数值；</p>
    <p class="text_indent2">如果字符串是空的，则会被转换为0；</p>
    <p class="text_indent2">如果字符串中包含除上述格式之外的字符，则将其转换为NaN;</p>
    <p class="text_indent">如果是对象，则调用对象的valueOf()方法进行相应的转换；疑问P30</p>
    <p>parseInt():</p>
    <p class="text_indent">此函数可以识别任何进制的数值，并将其转换为10进制的数值；</p>
    <p class="text_indent">此函数会忽略字符串前面的空格，直到找到第一个非空字符串；如果第一个字符不是数字字符或者负号，此函数会返回NaN;此函数转换空字符串会返回NaN;如果第一个数是数字字符则会继续解析后面的字符，直至结束，后面的某一个字符如果不是数字字符则从此之后的所有字符会被忽略；</p>
    <p class="text_indent">在ECMAScript 5 JavaScript引擎中，此函数已经不具备解析八进制的能力了；需要使用第二个参数指定进制数，parseInt("0xaf",16),此格式中的"0x"可以省略，但是如果不指定进制数是不可以省略的;</p>
    <p>parseFloat():</p>
    <p class="text_indent">此函数只解析十进制的数值，会把16进制的数值解析为零；</p>
    <p>toString():字符串转换方法，数值、布尔值、对象和字符串都有toString()方法；但null和undefined值没有这个方法；如果是数值时调用这个方法可以把进制数作为参数传递给此方法，输出相应进制数的字符串形式；</p>
    <p>String():此方法能将任何类型的数据转换为字符串；</p>
    <p class="text_indent">如果值有toString()方法，则调用该方法并返回相应结果；</p>
    <p class="text_indent">如果值为null,则返回“null”；</p>
    <p class="text_indent">如果值为undefined，则返回“undefined”；</p>
    <p>在ECMAScript中，如果不给构造函数传参数，则可以省略后面的那一对括号，但不推荐这种做法：var o = new Object;</p>
    <p>在ECMAScript中，Object类型是所有它的实例的基础。换句话说，Object类型所具有的任何属性和方法也同样存在更具体的对象中；</p>
    <p>Object的每个实例都具有下列属性和方法：疑问P35</p>
    <p class="text_indent">constructor:保存着用于创建当前对象的函数。</p>
    <p class="text_indent">hasOwnProperty(propertyName):用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（propertyName）必须以字符串形式指定（例如：o.hasOwnProperty("name")）；</p>
    <p class="text_indent">isPropertypeOf(object):用于检查传入的对象是否是传入对象的原型；</p>
    <p class="text_indent">propertyIsEnumerable(propertyName):用于检查给定的属性是否能够使用for-in语句来枚举，参数的属性名必须以字符串形式指定；</p>
    <p class="text_indent">toLocalString():返回对象的字符串表示，该字符串与执行环境的地区对应；</p>
    <p class="text_indent">toString():返回对象的字符串表示；</p>
    <p class="text_indent">valueOf():返回对象的字符串、数值或布尔值表示，通常与toString()方法的返回值相同；</p>
    <p>BOM和DOM中的对象都属于宿主对象，因为他们都是由宿主实现提供和定义的。ECMA-262不负责定义宿主对象，因此宿主对象可能会也可能不会续承Object;</p>
    <p>只能操作一个值的操作符叫做一元操作符；</p>
    <p>递增和递减操作符分为：前置型和后置型；</p>
    <p class="text_indent">前置型：在当前语句结束之前进行计算；</p>
    <p class="text_indent">后置型：在当前语句结束之后进行计算；</p>
    <p>递增递减的前置型和后置型操作符不仅适用整数还适用于字符串、布尔值、浮点数值、和对象，但是要想将其转换为数值在进行计算；</p>
    <p>一元加操作符以一个加号（+）表示，放在数值前面，对数值不会产生任何影响；如果对非数值应用一元加操作符时，该操作符会像Number()转型函数一样对这个值进行转换；</p>
    <p>在将一元减操作符应用于数值时，该值会变成负数；而当应用于非数值时，会按照一元加操作符规则转换数值，最后再将得到的数值转换为负数；</p>
    <p>一元加和减操作符主要用于基本的算数运算，也可以像用于数据类型的转换；</p>
    <p>位操作符：此过程是在后台底层完成的，所以速度较快，不用过多关注，很少用到；</p>
    <p class="text_indent">位操作符用于在最基本的层次上，即按内存中表示数值的位来操作数值。</p>
    <p class="text_indent">对于有符号的整数，32位中的前31位用于表示整数的值；第32位用于表示数值的符号：0表示正数，1表示负数，这个表示符号的位叫做符号位；正数以纯二进制格式存储，负数以二进制补码（反码加一）的格式存储；</p>
    <p class="text_indent">按位非操作符由一个波浪线（~）表示，执行按位非的结果就是返回数值的反码；操作数的负值减一；</p>
    <p class="text_indent">按位与操作符由一个和号字符（&）表示，它有两个操作数；</p>
    <p class="text_indent">按位或操作符由一个竖线符号（|）表示，同样也有两个操作数；</p>
    <p class="text_indent">按位异或操作符由一个插入符号（^）表示，同样也有两个操作数；</p>
    <p class="text_indent">左移操作符由两个小于号（&lt&lt）表示，这个操作符会将数值的所有位向左移动指定的位数，右侧多出的空位会以0来填充，以便得到一个完整的32位二进制数，左移不会影响操作数的符号位；</p>
    <p class="text_indent">有符号右移操作符由两个大于号（&gt&gt）表示，这个操作符会将数值向右移动指定的位数，多出的空位会以符号位的值来填充，以便得到一个完整的32位二进制数，左移不会影响操作数的符号位；</p>
    <p class="text_indent">无符号右移操作符由3个大于号（&gt&gt&gt）表示，这个操作符会将数值向右移动指定的位数，对于负数来说多出的空位会以0来填充，以便得到一个完整的32位二进制数，左移不会影响操作数的符号位；</p>
    <p>布尔操作符一共有三个：非（NOT）、与（AND）、或（OR）;布尔值却只有两个：true和false;</p>
    <p>同时使用两个逻辑非操作符实际上就会模拟Bloolean()转型函数的行为；</p>
    <p>逻辑与操作符（&&）可以应用于任何类型的操作数，在有一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值，此时，它遵循下列规则：疑问P45</p>
    <p class="text_indent">如果有一个操作数是null,则返回null;</p>
    <p class="text_indent">如果有一个操作数是NaN,则返回NaN;</p>
    <p class="text_indent">如果有一个操作数是undefined,则返回undefined;</p>
    <p>逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会对第二个操作数求值；</p>
    <p>逻辑或操作符（&&）可以应用于任何类型的操作数，在有一个操作数不是布尔值的情况下，逻辑或操作就不一定返回布尔值，此时，它遵循下列规则：疑问P45</p>
    <p class="text_indent">如果有两个操作数是null,则返回null;</p>
    <p class="text_indent">如果有两个操作数是NaN,则返回NaN;</p>
    <p class="text_indent">如果有两个操作数是undefined,则返回undefined;</p>
    <p>逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会对第二个操作数求值；</p>
    <p>ECMAScript定义了3个乘性操作符：乘法、除法和求摸；</p>
    <p>如果是Infinity与0相乘，则结果是NaN,与非零数值相乘则是Infinity或-Infinity，与Infinity相乘则结果是Infinity;</p>
    <p>如果是Infinity被Infinity除，则结果为NaN;如果0被0除，则结果为NaN;如果是非零的有限数被零除，则结果是Infinity或-Infinity；如果是Infinity被任何非零数值除，则结果是Infinity或-Infinity；</p>
    <p>求摸（余数）操作符是由一个百分号“%”表示，用法如下：</p>
    <p class="text_indent">如果被除数是无穷大值而除数是有限大值，则返回NaN;</p>
    <p class="text_indent">如果被除数是有限大值而除数是0，则返回NaN;</p>
    <p class="text_indent">如果是Infinity被Infinity除，则结果是NaN;</p>
    <p class="text_indent">如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数；</p>
    <p>加性操作符：</p>
    <p class="text_indent">如果是Infinity加-Infinity，则结果是NaN;</p>
    <p class="text_indent">如果一个操作数是字符串，则将另一个操作数转化为字符串，然后再将两个字符串拼接起来；</p>
    <p class="text_indent">如果想先对数值执行算数计算，然后再将结果与字符串串联起来，应该先用一对圆括号把两个数值变量括在一起，这样就会告诉解析器先计算其结果，然后再将结果与字符串拼接起来。</p>
    <p>关系操作符：如果两个操作数都是字符串，则比较两个字符串对应的字符编码值，大写字母的字符编码全部小于小写字母的字符编码；</p>
    <p>如果比较两个数字字符串，则会比较字符串中首个字符串的编码的大小；</p>
    <p>任何操作数与NaN进行关系比较，结果都是false;</p>
    <p>相等操作符：</p>
    <p class="text_indent">相等和不相等：先转换再比较（强制转型）；全等和不全等：仅比较而不转换；</p>
    <p>赋值操作符:</p>
    <p class="text_indent">如果在等于号（=）前面再添加乘性操作符、加性操作符或位操作符，就可以完成复合赋值操作。</p>
    <p>逗号操作符在用于赋值时，总会返回表达式中的最后一项：var num=(5,1,0,8);mum的值为8；</p>
    <p>在for循环的变量初始化表达式中，也可以不使用var关键字，可以将初始化的操作放在外部；</p>
    <p>由于ECMAScript中不存在块级作用域，因此在for循环内部定义的变量也可以在外部访问到；</p>
    <p class="text_indent">for循环语句的小括号中的三个语句都可以任意省略，如果全部省略则是一个无限循环；</p>
    <p class="text_indent">for/in语句是一种精准的迭代语句，可以用来枚举对象的属性。</p>
    <p>break语句会立即退出循环，强制继续执行循环后面的语句；而continue语句虽然也是立即退出，但是退出循环后会从循环的顶部继续执行。</p>
    <p><pre>
           start：for(var i=0;i&lt count;i++){
               for(var j=0;i&lt count;j++){
                   break/cotinue start
               }
           }
    lable语句可以同时结束内、外部循环；
    </pre></p>
    <p>switch语句（是为了简化if语句）中的每一种情形（case）的含义是：如果表达式等于这个值（value）,则执行后面的语句（statement）。而break关键字会导致代码执行流跳出switch语句；如果省略break,就会导致继续执行下一个case语句；最后的default用于没有相匹配的情况才执行此语句；疑问：P62</p>
    <P>return语句会让代码立即停止退出，如果后加数据则会传递数据，如果不加数据则会返回undefined值；</P>
    <P>ECMAScript函数不介意传递进来多少参数，也不在乎传进来的参数是什么类型,命名的参数只是提供便利但不是必须的；原因是ECMAScript中的参数在内部是用一个数组（类似数组，但并不是Array实例）来表示的，在函数体内可以通过argument对象来访问这个数组，从而获取传递给函数的每一个参数，也可以通过length属性获取参数的个数；并且argument对象可以与命名参数一起使用，但是由于argument对象的长度是由传入的参数个数传入的，不是由定义函数时的命名参数的个数决定的，所以如果传入参数的个数少于命名参数的个数，那么与缺少的传入参数相对应的命名参数将不会存在argument[i],此时的值是undefined；</P>
    <p>JavaScript的核心语言特性在ECMAS-262中是以名为ECMAScript的伪语言的形式来定义的；</p>
    <h1>第四章：变量、作用域和内存问题</h1>
    <p>ECMAScript变量可能包含两种不同的数据类型的值：</p>
    <p class="text_indent">基本类型值：指的是简单的数据段，可以操作保存在变量中的实际的值，复制操作时复制的内存数据，存储在栈内存中；</p>
    <p class="text_indent">引用类型值：指的是有多个值构成的对象，由于对象是保存在内存中的，JavaScript不能直接操作对象的内存空间，所以只能操作对象的引用（数据的存储路径，复制操作时是复制的对象的内存路径，但添加属性是操作实际对象）；存储在堆内存中；</p>
    <p>ECMAScript中所有函数的参数都是按值传递的。在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（参数实际上是函数的局部变量）；在向参数传递引用类型的值时，会把这个值在内存中的地址赋值给一个局部变量，因此这个局部变量的变化会反应在函数的外部。</p>
    <p>检测是什么类型的对象：result = variable instanceof constructor;</p>
    <p>执行环境和作用域：</p>
    <p class="text_indent">每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象（我们无法访问此对象但是后台解析会用它·）中。</p>
    <p class="text_indent">全局执行环境是最外围的一个执行环境；根据ECMAScript实现所在的宿主环境不同，表示执行环境的对象也不一样，在web浏览器中，全局执行环境被认为是window对象，因此所有全局变量和函数都是作为window对象的属性和方法创建的；</p>
    <p class="text_indent">某个执行环境中的所有代码被执行完毕后，该环境会被销毁，保存在其中的所有变量和函数定义也随之销毁；</p>
    <p class="text_indent">每个函数都有自己的执行环境；</p>
    <p class="text_indent">当代码在一个环境中执行时，会创建变量的一个作用域链；作用域链的用途：保证对执行环境有权访问的所有变量和函数的有序访问；作用域链的前端，始终都是当前执行的代码所在环境的变量对象；如果这个环境是函数，则将其活动对象作为变量对象；活动对象起初只包含一个变量———argument对象（这个对象在全局环境中是不存在）；作用域链的末端是全局执行环境的变量对象；标识符的解析式沿着作用域链由内向外一级一级地搜索标识符的过程；</p>
    <p class="text_indent">内部环境可以通过作用域链访问所有外部环境，但外部环境不能访问内部环境中的任何变量和函数；</p>
    <p>对于JavaScript来说，由for语句或者if语句创建的变量，即使在他们执行结束后也会存在循环外部的执行环境中；</p>
    <p>使用var声明的变量会自动被添加到最接近的环境中；如果初始化变量时没有使用var声明，该变量会自动被添加到全局环境中；在严格模式下，初始化未经声明的变量会导致错误；</p>
    <p>如果声明了一个与全局变量同名的局部变量，在局部变量之后如果想要使用全局变量，则必须通过window.color方式进行访问全局变量；</p>
    <p>JavaScript具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存；</p>
    <p>JavaScript中最常用的垃圾收集方式是标记清除的；另一种不太常用的垃圾收集策略叫做引用计数。</p>
    <p>解除引用：将变量设置为null,意味着切断变量与它此前引用的值之间的链接，这个做法主要用于大多数全局变量和全局对象的属性；接触一个值的引用真正的作用是让值脱离执行环境，以便垃圾收集器将其回收；</p>
    <h1>第五章：引用类型</h1>
    <p>引用类型的值（对象）是引用类型的一个实例。在ECMAScript中，引用类型是一种数据类型，用于将数据和功能组织在一起。引用类型有时候也被称作对象定义，因为他们描述的是一类对象所具有的属性方法；</p>
    <p>新对象是使用new操作符后跟一个构造函数来创建的。构造函数本身就是一个函数，只不过该函数是出于创建新对象的目的而定义的。</p>
    <p>ECMAScript提供了很多原生引用类型（如Object）,以便开发人员用以实现常见的计算任务。</p>
    <p>创建Object的实例的方式有两种。一种是使用new操作符后跟Object构造函数；另一种是使用对象字面量表示法。</p>
    <p>使用对象字面量语法时，属性名也可以使用字符串；</p>
    <p>在通过对象字面量表示法定义对象/数组时，实际上大多数浏览器不会调用Object、Array构造函数。</p>
    <p>在JavaScript中也可以使用方括号表示法来访问对象；在使用方括号语法时，应该将要访问的属性以字符串的形式放在括号中；方括号表示法的优点是可以通过变量的方式来访问对象的属性；如果属性名中包含会导致语法错误的字符（属性名中是可以包含非字母非数字的），或者属性名使用的是关键字或保留字，也可以使用方括号表示法；</p>
    <p>创建数组的方式有两种:</p>
    <p class="text_indent">第一种是使用Array构造函数（new操作符可以省略）:可以以参数的形式把数组的项数或者每一项的值传递给构造函数；</p>
    <p class="text_indent">第二种是使用数组字面量表示法；</p>
    <p>数组的length属性很有特点，他不是只读的，他也可以从数组的末尾移除项或向数组中添加新项；array[array.length]="array1";</p>
    <p>如果将其length属性设置为大于数组项数的值，则新增的每一项都会取得undefined值；</p>
    <p>对于一个网页或者一个全局作用域检测某个对象是不是数组的方法：value instanceof array；对于一个或者多个全局执行环境中检测某个对象是不是数组的方法：Array.isArray(value);</p>
    <p>toString()方法：可以把数组的每一项以字符串的类型拼接在一起，并用逗号隔开来输出；</p>
    <p>valueof()方法：还是返回数组；</p>
    <p>toLocaleString()方法：调用是数组中每一项的toLocaleString()方法；</p>
    <p>join()方法：把分隔符当做参数传入，将数组的每一项会用分隔符隔开；</p>
    <!-- <p>栈方法：最先添加的项最早被移除；</p> -->
    <p class="text_indent">push()方法：把数据添加到数组的末尾，并返回修改后数组的长度；</p>
    <p class="text_indent">pop()方法：把数据从数组末尾移除，并返回移除的项；</p>
    <p class="text_indent">shift()方法：把数据从数组头部移除，并返回移除的项；unshift()方法：把数据添加到数组头部，并返回修改后数组的长度；</p>
    <p>重排序方法：</p>
    <p class="text_indent">reverse()方法:翻转数组项的排列顺序；</p>
    <p class="text_indent">sort()方法：按升序排列数组项，此方法会调用每个数组项的toString()转换方法，然后比较得到的字符串；即使数组中的每一项都是数字，此方法比较的也是字符串；此方法可以接收一个函数作为参数，以便排列数组数值项的顺序；</p>
    <pre>
        function compare(value1,value2){
            if (value1 &lt value2){
                return -1;
            }else if(value1 &gt value2){
                return 1;
            }else{
                return 0;
            }
        }

        或者：

        function compare(value1,value2){
            return value2 - value1; 
        }        
    </pre>
    <p>concat()方法：将传递的参数（多个参数之间用逗号隔开）添加到数组项的末尾，最后返回新构建的数组；其原数组不变；</p>
    <p>slice()方法：可以接收一或两个参数，如果是一个参数则是从参数位置项到结束，若果是连个参数则是两参数之间的数组项（不包括第二个参数位置项）；如果此方法的参数是一个负数，相当于倒着数，0，-1,-2....;
    </p>
    <p>splice(所要删除的项的起始位置，所要删除的项数，所要插入的项项)方法：向数组的中部插入/删除项；此方法会返回从原始数组中删除的项；</p>
    <p>indexOf()和；lastIndexOf()方法：这两个方法可以接收两个参数--要查找的项和表示查找起点位置的索引（可选），返回要查找的项在数组中第一次出现的位置，如果没找到会返回-1，</p>
    <p>数组迭代方法：每个方法搜接收两个参数--要在每一项上运行的函数和运行该函数的作用域对象；传入这些方法中的函数接收三个参数--数组项的值、该项在数组中的位置和数组对象本身；这些方法都会改变数组中包含的值；</p>
    <p class="text_indent">every():对数组中的每一项运行给定函数，如果该函数对每一项都返回true,则返回true。</p>
    <p class="text_indent">some():对数组中的每一项运行给定函数，如果该函数对任一项返回true,则返回true。</p>
    <p class="text_indent">filter():对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。</p>
    <p class="text_indent">forEach():对数组中的每一项运行给定函数，这个方法没有返回值。本质上与for循环迭代数组一样。</p>
    <p class="text_indent">map():对数组中的每一项运行给定函数，返回每次函数调用的结果（加减乘除等操作之后的结果）组成的数组。</p>
    <p>归并方法：</p>
    <p class="text_indent">reduce()和redece()方法：这两个方法都会迭代数组的所有项然后构建一个最终返回的值；这两个方法都会接收两个参数--一个在每一项上调用的函数和（可选的）作为归并基础的初始值；被当做参数的传进来的函数可以接收四个参数--前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项；</p>
    <p>创建日期对象的方式：使用new操作符和Date构造函数；构造函数无参数的情况下会自动获取当前日期和时间；如果传入某一时间的毫秒数，则会获得某一时间的对象；</p>
    <p>Date.parse()方法：将传入的日期（因地区而异）字符串参数转换成毫秒数；如果把日期字符串直接传给构造函数，后台也会直接调用Date.parse()转换成毫秒数；月日年</p>
    <p>Date.UTC()方法：也是将日期转换成毫秒数，格式是月日年 ....月和小时是从0开始计数的；如果把日期字符串直接传给构造函数，后台也会直接调用Date.UTC()转换成毫秒数；</p>
    <p>Date.now()方法：返回表示调用这个方法时的日期和时间的毫秒数；在不支持此方法的浏览器中使用+操作符把Date对象转换成字符串也可以达到同样的目的：+new Date()相当于Date.now()；</p>
    <p>Date类型的方法：toLocaleString()方法：以电脑设置的本地时间为准，会出现AM、PM;toString()方法：会输出带有时区的时间格式；value()方法：返回毫秒数；</p> 
    <p>Date类将日期格式化为字符串的方法：</p>
    <p class="text_indent">toDateString():以特定于实现的格式显示星期几、月、日和年；</p>
    <p class="text_indent">toTimeString():以特定于实现的格式显示时、分、秒和时区；</p>
    <p class="text_indent">toLocaleDateString():以特定于地区的格式显示星期几、月、日和年;</p>
    <p class="text_indent">toLocaleTimeString():以特定于实现的格式显示时、分、秒;</p>
    <p class="text_indent">toUTCString():以特定于实现的格式完整的UTC日期；</p>
    <p>正则表达式：</p>
    <p class="text_indent">字面量形式var expression = /pattern/flags;</p>
    <p class="text_indent2">g:全局模式；i:表示不区分大小写模式；m:表示多行模式；</p>
    <p class="text_indent2">正则表达式使用的元字符都必须转义；</p>
    <p class="text_indent">构造函数创建正则表达式：var expression = new RegExp(匹配的字符串模式,可选的标志字符串)：匹配的字符串模式不带右斜杠;</p>
    <p>RegExp实例属性：</p>
    <p class="text_indent2">global:布尔值，是否设置了g标志；</p>
    <p class="text_indent2">ignoreCase:布尔值，表示是否设置了i标志；</p>
    <p class="text_indent2">lastIndex:整数，表示开始搜搜下一个匹配项的字符位置，从零算起；</p>
    <p class="text_indent2">multiline:布尔值，表示是否设置了m标志；</p>
    <p class="text_indent2">source:正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回；</p>
    <p>疑问：RegExp实例方法P106;RegExp构造函数属性P107；模式的局限性P109；</p>
    <p>函数实际上是对象，每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上是一个指向函数对象的指针，不会与某个函数绑定；</p>
    <p class="text_indent">函数声明语法定义格式：</p>
    <pre>
    function sum (num1,num2){
        return num1 + num2;
    }
    </pre>
    <p class="text_indent">函数表达式定义函数格式：函数末尾有一个分号，就像声明其他变量一样；</p>
    <pre>
        var sum = function(num1,num2){
            return num1 + num2;
        };
    </pre>
    <p class="text_indent">使用Function构造函数创建函数：Function构造函数可以接收任意数量的参数，但是最后一个参数始终都被看成是函数体，而前面的参数则枚举出了新函数的参数；此方法不推荐使用；但是这种语法对于理解“函数是对象，函数名是指针”的概念倒是非常直观的；</p>
    <pre>
        var sum = new Function("num1","num","return num1 + num2");
    </pre>
    <p>使用不带圆括号的函数名是访问函数指针而非调用函数；</p>
    <p>没有重载：在一个文档里有两个不同执行块的同名函数，第二个函数会覆盖第一个函数，本质上是第二个函数对象变量覆盖了第一个函数对象变量对象；</p>
    <p>解析器会率先读取函数声明，并使其在执行任何代码之前可以访问（尽量优先使用函数声明）；而函数表达式，则必须等到解析器执行到他所在的代码行才会真正解释执行；</p>
    <p>函数名本身就是变量，所以函数也可以作为值来使用。不仅可以像传递参数一样把一个函数传递给另一个函数，而且还可以将一个函数作为另一个函数的结果返回；</p>
    <p>函数内部属性：argument对象和this对象；</p>
    <p class="text_indent">argument对象是一个类数组对象，其有一个属性callee，该属性是一个指针，指向拥有这个argument对象的函数；</p>
    <p class="text_indent">this对象：引用的是函数据以执行的环境对象，当在网页的全局作用域中调用函数时this对象引用的就是window;</p>
    <p class="text_indent">caller属性：这个属性中保存着调用当前函数的函数的引用，如果在全局作用域中调用当前函数，他的值为null；疑问：P115</p>
    <P>函数的属性length:表示函数希望接收的命名参数的个数；</P>
    <p>每个函数都包含两个非续承而来的方法：apply()和call();这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内的this对象的值；首先，apply()方法接收连个参数，一个是在其中运行的函数的作用域，另一个是参数组；第二个参数可以是Array的实例或者argument对象；call()方法不同点是：除this之外的参数都要一一罗列出来而不能是一个对象或者数组；使用这两个方法来扩充作用域的最大好处是对象不需要与方法有任何耦合关系；</p>
    <p>bind()方法：此方法会创建一个函数的实例，其this值会被绑定到传给bind（）函数的值；也就是设置作用域不传参数；</p>
    <p>每个函数续承的toLocalString()、toString()和valueOf()都是返回函数代码；</p>
    <p><strong>基本包装类型：</strong></p>
    <p>从逻辑上讲基本类型值不是对象，因而不应该有方法和属性；但是为了便于操作基本类型值，实际上每当读取一个基本类型值的时候，后台就会创建一个与之对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据；故此，ECMAScript还提供了3个特殊的引用类型：Boolean、Number和String;</p>
    <pre>
        var s1 = new String("some text");
        var s2 = s1.substring(2);
        s1 = null;
    </pre>
    <p>引用类型和基本包装类型的主要区别就是对象的生存期；后台自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁；这意味着我们不能再运行时为基本类型添加属性和方法；</p>
    <p>Object 构造函数也会像工厂方法一样，根据传入值的类型返回相应基本类型的实例：</p>
    <pre>
        var obj = new Object("some text");
        alert(obj instanceof String);//true
    </pre>
    <p>把字符串传给Object构造函数，就会创建String的实例；而传入数值会得到Number的实例，传入布尔值参数就会得到Boolean的实例；</p>
    <p>要注意的是使用new调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的；</p>
    <pre>
        var value "25";
        var number = Number(value);
        alert(typeof number);//"number"

        var obj = new Number(value);
        alert(typeof obj);//"object"
    </pre>
    <p>Boolean类型：var booleanObject = new Boolean(true);</p>
    <p>布尔表达式中的所有对象都会被转换为true;</p>
    <p>Number类型：</p>
    <pre>
        var numberObject = new Number(10);
    </pre>
    <p>toFixed()方法：会按照参数指定的小数位返回数值的字符串表示；</p>
    <p>toExponential()方法:该方法返回以指数表示法（也称e表示法）表示的数值的字符串形式；</p>
    <p>toPrecision()方法：会返回合适格式的数字表示方式；这个方法接收一个参数，即表示数值的所有数字的位数；</p>
    <p>String类型：var stringObject new String("hello world");</p>
    <p>charAt()方法：返回参数指定位置的字符；charAt()方法：返回参数指定位置的字符的编码；</p>
    <p>方括号加数字索引来访问字符串中的特定字符；stringValue[1]</p>
    <p>concat()方法：将一个字符串与另一个或者多个字符串拼接起来，返回拼接得到的新字符串，可以接收任意多个参数，此方法相当于+操作符，原字符串不变；</p>
    <p>基于原字符串创建新字符串的方法：</p>
    <p class="text_indent">slice(字符串开始位置，字符串结束位置的后一个索引)方法：返回一个新字符串；会将负值参数与字符串长度相加；</p>
    <p class="text_indent">substring(字符串开始位置，字符串结束位置的后一个索引)方法：返回一个新字符串；会将第一个负值参数与字符串长度相加，将第二个参数转换为0；会把所有负值参数都转化为零‘</p>
    <p class="text_indent">substr(字符串开始位置，字符个数)方法：返回一个新字符串；会将第一个负值参数与字符串长度相加，将第二个参数转换为0；</p>
    <p>字符串位置方法：</p>
    <p class="text_indent">indexOf()和lastIndexOf()方法：这两个方法都是从一个字符串中搜索给定的子字符串，然后返回字符串的位置，如果没找到则是返回-1；前一个方法是从开头往后搜索，后一个方法是从后往前搜索；这两个方法都可以接受第二个参数，表示从字符串中的哪个位置开始搜索；</p>
    <p>trim()方法：这个方法为字符串创建了一个字符串副本，删除前置及后缀的所有空格，然后返回结果；</p>
    <p>字符串大小写转换方法：</p>
    <p class="text_indent">toLowerCase()和toUpperCase()方法:是两个常用的转换大小写方法；</p>
    <p class="text_indent">toLocaleLowerCase()和toLocaleUpperCase()方法：是两个和地区有关的转换大小写方法；</p>
    <p>字符串的模式匹配方法：match()方法：只接受一个参数，要么是正则表达式，要么是一个RegExp对象；search()方法与match()语法接近，但是返回字符串在第一个匹配项的索引，如果没有则会返回-1；</p>
    <p>replce()方法：第一个参数可以是字符串或者是一个RegExp对象，第二个参数可以是一个字符串或者是一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串。要想替换所有字符串，唯一的办法就是提供一个正则表达式，而且要指定全局g标志；如果第二个参数是一个函数，此函数可以对被替换的字符串进行操作，此函数接收三个参数匹配项、匹配项的索引和原字符串；</p>
    <p>split()方法：可以将一个字符串用指定的分隔符分隔成多个子字符串，并将结果放在一个数组中；分隔符既可以是字符串也可以是RegExp对象；可以接收第二个参数用于指定数组的大小；</p>
    <p>localeCompare()方法：这个方法比较两个字符串并返回-1、0、1；</p>
    <p>fromCharCode()方法：将数个字符串编码转换为字符串；</p>
    <p>ECMA-262对内置对象的定义是：“由ECMAScript实现提供的、不依赖于宿主环境的对象，这些对象在ECMAScript程序执行之前就已经存在了。”这些内置对象不需要显示地实例化内置对象，因为他们已经实例化了；ECMA-262还定义了两个单体内置对象：Global和Math;</p>
    <p>Global（全局）对象不属于任何其他对象的属性和方法，所有在全局作用域中定义的属性和函数都是Global对象的属性；</p>
    <p>URI编码方法：可以对URI进行编码以便发送给浏览器；</p>
    <p>encodeURI()方法：主要用于对整个URI进行编码,不会对特殊字符进行编码--冒号、正斜杠、问号和井号；会把空格替换成%20；返编码方法decodeURI();</p>
    <p>encodeURIComponent()方法：主要用于URI中的某一段进行编码,会对任何非标准字符编码；返编码方法decodeURIComponent();</p>
    <p>eval()方法：此方法就像一个完整的EMACScript解析器，他只接受一个参数，就是要执行的JavaScript代码；通过该方法执行的代码具有与执行环境相同的作用域链；在此方法中创建的变量和函数不会被提升，它只有在此方法执行的时候创建；严格模式下会出问题；</p>
    <p>ECMAScript虽然没有指出如何访问Global对象，但Web浏览器都是将这个全局对象作为window对象的一部分加以实现的。因此在全面作用域中声明的所有变量和函数就都成了window对象的属性；</p>
    <p>min()和max()方法：是Math对象的方法，用于确定一组数中的最大值和最小值，这两个函数可以接收任意数量的数值作为参数；</p>
    <pre>
        var values = [1,2,3,4,5,6,7,8];
        var max = Math.max.apply(Math,values);
    </pre>
    <p>舍入方法：</p>
    <p class="text_indent">Math.ceil():执行向上舍入，即它总是将数值向上舍入为最近的整数；</p>
    <p class="text_indent">Math.ceil():执行向上舍入，即它总是将数值向上舍入为最近的整数；</p>
    <p class="text_indent">Math.round():执行标准舍入，即它总是将数值四舍五入为最近的整数；</p>
    <p>random()方法：返回大于等于0小于1的一个随机数；</p>
    <p>引用类型与传统面向对象程序设计中的类相似，但实现不同；</p>
    <p>RegExp类型是ECMAScript支持正则表达式的一个接口，提供了最基本的和一些高级的正则表达式功能；</p>
    <h1>第六章：面向对象的程序设计</h1>
    <p>面向对象的语言有一个标志，那就是它们都有类的概念，而通过类可以创建任意多个具有相同属性和方法的对象；</p>
    <p>属性类型：数据属性和访问器属性；</p>
    <p class="text_indent">属性的特征是为了实现JavaScript引擎用的，因此JavaScript不能直接访问它们；要修改属性默认的特性，必须通过Object.defineProperty();为了表示属性的特征是内部值，该规范把他们放到了两对方括号中--[[Enumerable]];</p>
    <p class="text_indent">数据属性有4个描述其行为的特性；</p>
    <p class="text_indent2">[[Enumerable]]:表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性；</p>
    <p class="text_indent2">[[Enumerable]]:表示能否通过for-in循环返回属性；</p>
    <p class="text_indent2">[[Writable]]:表示能否修改属性的值；</p>
    <p class="text_indent2">[[Value]]:包含这个属性的数据值；</p>
    <p class="text_indent">要修改属性默认的特性，必须通过Object.defineProperty();这个方法接收三个参数：属性所在的对象、属性的名字、和一个描述符对象（此对象的属性必须是属性的特性属性）；</p>
    <p>一旦把属性定义为不可配置的就不能把它再变回可配置了；</p>
    <p class="text_indent">访问器属性的四个特性：</p>
    <p class="text_indent2">[[Enumerable]]:表示能否通过delete删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性；</p>
    <p class="text_indent2">[[Enumerable]]:表示能否通过for-in循环返回属性；</p>
    <p class="text_indent2">[[GET]]:在读取属性时调用的函数；默认值为undefined;</p>
    <p class="text_indent2">[[SET]]:在写入属性时调用的函数；默认值为undefined;</p>
    <p class="text_indent">访问器属性不能直接定义，必须通过Object.defineProperty()来定义;</p>
    <P class="text_indent">_year前面的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性；</P>
    <p class="text_indent">Object.defineProperties()方法：此方法一次定义多个属性，此方法接收两个对象参数，一个是要添加和修改其属性的对象，第二个对象是所要修改的对象的属性的集合；通过此方式定义的对象属性都是同一时间创建的；</p>
    <p class="text_indent">Object.getOwnPropertyDescriptor()方法：可以获取给定属性的描述符，这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回是一个对象。</p>
    <p>Object构造函数和对象字面量创建的对象有个明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码；为了解决这个问题人们开始使用工厂模式的一种变体；</p>
    <p>工厂模式把创建对象过程中重复必要的代码部分封装到一个函数中，然后通过传参的形式随意的调用这个函数创建对象；工厂模式虽然解决了创造多个相似对象的问题，但却没有解决对象识别问题（即怎么知道一个对象的类型）；</p>
    <p>构造函数模式：即自定义的构造函数；通过创建自定义的构造函数，从而定义自定义对象类型的属性和方法；</p>
    <p>构造函数模式的函数名要大写；要通过new操作符来创建构造函数模式的新实例；构造函数模式创建的新实例对象都有一个constructor属性，且该属性指向自定义构造函数；新实例既属于Object的实例，也属于自定义构造函数的实例；</p>
    <p>创建自定义的构造函数意味着将来可以将他的实例标识为一种特定的类型，而这正是构造函数模式胜过工厂模式的地方；</p>
    <p>构造函数与其他函数的唯一区别，就在于调用他们的方式不同；任何函数，只要通过new操作符来调用，那他就可以作为构造函数；而任何函数，如果不同过new操作符来调用，那他跟普通函数也不会有什么两样；也就是说自定义构造函数可以通过多种方式调用--当做构造函数使用、作为普通函数使用、在另一个对象的作用域中调用；</p>
    <p>构造函数模式虽然解决了创建的对象的类型的问题，但是却出现了每个方法都要在每个实例上重新创建一遍（函数本身的作用就封装一次无数次调用）且是不同对象的方法；为了解决构造函数模式的这个问题需要：自定义函数内部的方法以全局函数形式放在函数外部，然后将此函数赋值给自定义构造函数内部的属性，这样就可以解决重复创建对象方法的问题；但是又出现了新的问题：在全局作用域中定义的函数实际上只能被某个对象调用，这让全局作用域有点名不副实；并且这样也便于封装；</p>
    <p>我们创建的每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法；即使原型模式中的构造函数是空函数，也可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属性和方法；</p>
    <p>只要创建一个函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象；在默认情况下，所有原型对象都会自动获得一个constructor属性，这个属性包含一个指向prototype属性所在函数的指针；</p>
    <P>创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性；至于其他方法，则都是从Object续承而来的；《构造函数-原型对象-对象实例》</P>
    <p>对象实例的内部属性[[prototype]]可以通过属性_proto_访问；可以通过Person.prototype.isPrototype(person1)来检测实例与对象原型之间的关系;</p>
    <p>Object.getPrototypeOf(Person1)方法：此方法返回[[Prototype]],即对象的原型;</p>
    <p>当代码读取某个对象的属性时。搜索首先会从对象实例本身开始，如果实例中有该属性则返回该属性；如果没有，找到则继续搜索指针指向的原型对象，在原型对象中查找该属性的名字；</p>
    <p>虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值，如果修改实例中的属性，该属性将会屏蔽原型中的那个
    同名属性；</p>
    <p>使用delete操作符则可以删除实例中的属性，从而让我们重新访问原型中属性：delete person1.name;</p>
    <p>person1.hasOwnProperty("name"):此方法检测一个属性是否来自于实例中;</p>
    <p>单独使用in操作符时，in操作符会在通过对象能够访问给定属性时返回true,无论该属性存在于实例中还是原型中:alert("name" in person2);//true</p>
    <p>在使用for-in循环时，返回的是所有能够通过对象访问的、可枚举的属性，其中既包括存在于实例中的属性也包括存在于原型中的属性。屏蔽了原型中的不可枚举属性的实例属性也会在for-in循环中返回，因为根据规定，所有开发人员定义的属性都是可枚举的；</p>
    <p>Object.keys()方法：此方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组；如果你想要得到所有实例属性，无论它是否可枚举，都可以使用Object.getOwnPropertyNames()方法;</p>
    <p>由于原型模式创建对象时需要重复输入Person.prototype,为了方便，可以把一个包含属性和方法的对象字面量表达式赋值给Person.prototype；但是这样对象的constructor属性就会被重置不能确定对象的类型，可以将constructor：Person;写入对象字面量表达式中来解决这个问题；</p>
    <p>因为实例与原型之间的链接只是一个指针，而非一个副本，因此就可以在原型中找到新的sayHi()属性并返回保存在那里的函数；</p>
    <p>如果重写整个原型对象，那么就等于切断了构造函数和最初原型之间的联系。实例中的指针仅指向原型，不指向构造函数；</p>
    <p>原型模式的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是菜用这种模式创建的。所有原生引用类型都在其构造函数的原型上定义了方法。通过原生对象的原型，不仅可以取得所有默认方法的引用，而且也可以定义新方法。</p>
    <p>原型对象的问题：对于包含引用类型值的属性来说，问题就比较突出了；当通过某个实例改变引用类型的属性值时，其他实例也会跟着改变；</p>
    <p>组合使用构造函数模式和原型模式是创建定义类型对象最常用的方式。自定义函数模式用于定义实例属性，而原型模式用于定义方法和共享属性；</p>
    <p>动态原型模式通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型；它把所有信息都封装到了构造函数中，而通过在构造函数中初始化原型，又把保持了同时使用构造函数和原型的优点；</p>
    <p>寄生构造函数模式可以在特殊的情况下用来为对象创建构造函数。假设我们想创建一个具有额外方法的特殊数组，由于不能直接修改Array构造函数，因此可以使用这个模式；有一点需要声明：首先返回的对象与构造函数或者与构造函数的原型属性之间没有关系；也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。</p>
    <p>稳妥构造函数模式最适合在一些安全的环境中（这些环境中会禁用this和new）使用，此模式与寄生构造函数模式有两点不同：一新创建对象的实例方法不引用this,二是不使用new操作符调用构造函数；此模式除了通过对象方法的方式调用其参数没有其他办法；</p>
    <h1>第七章：函数表达式</h1>
    <p>定义函数的方式有两种：函数声明方式和函数表达式；</p>
    <p>主流浏览器给函数定义了一个非标准的name属性，通过这个属性可以访问到函数的名字；</p>
    <p>关于函数声明，它的一个重要特征就是函数声明提升，意思是在执行代码之前会先读取函数声明，这就意味着可以把函数声明放在调用它的语句后面；</p>
    <p>通过函数表达式定义的函数叫做匿名函数，匿名函数的name属性是空字符串；函数表达式与其他表达式一样，使用前必须先赋值；</p>
    <p>理解函数提升的关键，就是理解函数声明与函数表达式之间的区别；</p>
    <p>通常情况下，为了方便调用全局函数，会在全局作用域使用函数声明定义函数；如果在if判断语句中，那么可以使用函数表达式定义函数；如果在if判断语句中使用函数声明方式定义函数会出现问题；</p>
    <p>arguments.callee是一个指向正在执行的函数的指针，因此可以用它来实现对函数的递归调用（严格模式下会出现错误）；</p>
    <p>命名函数表达式，疑问：P178</p>
    <p>闭包是指有权访问另一个函数作用域的变量的函数；</p>
    <p>当某个函数被调用时，会创建一个执行环境及相应的作用域链；然后，使用argunments和其他命名参数的值来初始化函数的活动对象（应该是作用域对象或执行环境对象或者变量对象）。疑问P178</p>
    <p>作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。</p>
    <p>由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存；</p>
    <p>作用域链的这种配置机制引出了一个值得注意的副作用，即闭包只能取得包含函数中任何变量的最后一个值。我们可以通过在闭包函数中创建一个立即执行函数解决这个问题；</p>
    <p>this对象是在运行时基于函数的执行环境绑定的：在全局函数中，this等于window,而当函数被作为某个对象的方法调用时，this等于那个对象。不过，<strong>匿名函数的执行环境具有全局性，因此其this对象通常指向window。</strong></p>
    <p>每个函数在被调用时都会自动取得两个特殊变量：this和arguments,内部函数在搜索这两个变量时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量；不过，如果把外部作用域中的this、argument对象保存在一个闭包能够访问到的变量里，就可以让闭包访问该对象了；</p>
    <p>第三行代码先执行了一条赋值语句，然后再调用复制后的结果。因为这个赋值表达式的是函数本身，所以this的值不能得到维持，结果就返回了“the window”；疑问：P183</p>
    <P>
    内存泄漏：通过将函数内部元素对象赋值给一个变量，然后用闭包函数引用这个变量，最后把元素对象设置为null解除对元素对象的引用,方便垃圾的回收；</P>
    <p>JavaScript没有块级作用域的概念，这意味着在块语句中定义的变量，实际上是在包含函数中而非语句中创建的；</p>
    <p>匿名函数可以用来模仿块级作用域（通常称为私有作用域）；(function(){//这里是块级作用域})();把函数声明包含在一对圆括号中，表示它实际上是一个函数表达式，而紧随其后的另一对圆括号会立即调用这个函数；</p>
    <p>模仿块级作用域这种技术经常用在全局作用域中被用在函数外部，从而限制向全局作用域中添加过多的变量和函数。在一个有很多人开发的大型项目中，过多的全局变量和函数很容易导致命名冲突，而通过创建私有作用域，每个开发人员即可以使用自己的变量，又不必担心搞乱全局作用域；</p>
    <p>JavaScript中没有私有成员的概念；所有对象属性都是公有的；但是在函数中定义的变量可以看做是私有变量--包括函数的参数、局部变量和在函数内部定义的其他函数；在函数的外部是不能访问局部变量的，但是可以通过创建一个闭包来访问私有变量；我们把有权访问私有变量和私有函数的公有方法称为特权方法；</p>
    <p>特权方法1：在构造函数中定义；此方法的缺点是必须针对每个实例都会创建同样一组新方法；</p>
    <p>特权方法2：静态私有变量，通过在私有作用域中定义私有变量或函数，同样也可以创建特权方法；</p>
    <p class="text_indent">这个模式的公有方法是在原型上定义的，并且在定义构造函数时并没有使用函数声明，而是使用了函数表达式；函数声明只能创建局部函数；并且在声明myObject时使用var关键字，记住：初始化未经声明的变量，总会创建一个全局变量，因此myObject就成了一个全局变量，能够在私有作用域外被访问到；</p>
    <p>方法2与方法1的主要区别就在于私有变量和函数是由实例共享的，由于特权方法是在原型上定义的，因此所有实例都是用同一个函数；以这种方式创建私有变量会因为使用原型而增进代码的复用，但是每个实例都没有自己的私有变量；</p>
    <p>多查找作用域链中的一个层次，就会在一定程度上影响查找速度，而这正是使用闭包和私有变量的一个明显不足之处；</p>
    <p>模块模式：疑问P189</p>
    <p>所谓单例指的就是只有一个实例对象，JavaScript是以对象字面量的方式来创建单例对象的；</p>
    <p>在Web应用程序中，经常需要使用一个单例来管理应用程序级的信息；</p>
    <p>简言之如果必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有数据的方法，那么就可以使用模块模式；以这种模式创建的每个单例都是Object的实例因为最终要通过一个对象字面量来表示它；单例通常都是作为全局对象存在的，我们不会将它传递格一个函数；</p>
    <p>增强的模块模式在返回对象之前加入对其增强的代码，这种增强的模块模式适合那些必须是某类型的实例，同时还必须添加某些属性或方法对其加以增强的情况；</p>
    <h1>第八章：BOM</h1>
    <P>BOM提供了很多对象，用于访问浏览器的功能，这些功能与任何网页内容无关；</P>
    <p>BOM的核心对象是window，他表示浏览器的一个实例；在浏览器中window对象有双重角色，它既是通过JavaScript访问浏览器窗口的一个接口，又是ECMAScript规定的Global对象；这意味着在网页中定义的任何一个对象、变量和函数都以window作为其Global对象；</p>
    <p>定义全局变量和在window对象上直接定义属性还是有一点差别的：全局变量不能通过delete操作符删除，而直接在window对象上定义的属性可以；因为使用var语句添加的window的属性的[[Configurable]]的特性的值被设置为了false,所以不能通过delete操作符删除；</p>
    <p>尝试访问未声明的变量会抛出错误，但是通过查询window对象，可以知道某个可能未声明的变量是否存在；</p>
    <p>如果页面中包含框架，则每个框架都拥有自己的window对象，并且保存在frames集合中；在frames集合中，可以通过数值的索引或者框架名称来访问相应的window对象。每个window对象都有一个name属性，其中包含框架的名称；</p>
    <p>引用框架的方式：window.frames[0]或者window.frames["topFrame"]、top.frames[0]或者top.frames["topFrame"]、frames[0]或者frames['topFrame'];</p>
    <p>top对象始终指向最高（最外）层的框架，也就是浏览器窗口。使用它可以确保在一个框架中正确的访问另一个框架；因为对于在一个框架中编写的任何代码来说，其中的window对象指向的都是那个框架的特定实例，而非最高层的框架；所以最好采用top对象引用框架；</p>
    <p>与top相对的另一个window对象是parent，parent对象始终指向当前框架的直接上层框架；parent有可能等于top;但在没有框架的情况下，parent一定等于top(此时他们都等于window);</p>
    <p>除非最高层窗口是通过window.open()打开的，否则window对象的name属性值不包含任何值；</p>
    <p>self对象始终指向window;实际上self和window对象可以互换使用；引入self对象的目的只是为了与top和parent对象对应起来，因此他不包含任何值；</p>
    <p>所有这些对象都是window对象的属性，可以通过window.parent、window.top、window.parent.parent.frames[0]等形式来访问；</p>
    <p>screenLeft和screenTop属性、screenX和screenY属性分别用于表示窗口相对应与屏幕左边和上边的位置；由于浏览器的兼容问题需要进行对象检测；有的是窗口的距离，有的是标签页的距离；最终结果导致无法在跨浏览器的条件下取得窗口左边和上边的精确坐标值；</p>
    <p>moveTo(x,y)：将浏览器窗口移动到某一位置；moveBy(disX,disY):将窗口位置移动一段指定的位置；这两个方法有可能会被浏览器禁用；</p>
    <p>innerWidth和innerHeight、outerWidth和outerHeight:有的浏览器返回浏览器窗口的尺寸，有的浏览器返回标签页的尺寸；有的浏览器不支持这两对属性，则通过DOM提供了相关信息：</p>
    <p>resizeTo():将浏览器窗口调整到某一尺寸大小；resizeBy():将浏览器窗口增加或减少某一尺寸；这两个方法也被有的方法禁用；</p>
    <p>window.open()方法：既可以导航到一个特定的URL也可以打开一个新的浏览器窗口；此方法接收四个参数：要加载的URL、窗口目标、一个特性字符串和一个表示新页面是否取代浏览器历史记录当中当前加载页面的布尔值；通常只需传递第一个参数，最后一个参数只在不打开新窗口的情况下使用；第二个参数可以窗口框架名字、_self、_parent、_top或者_blank;此方法还会返回一个指向新窗口的引用；colse()方法可以关闭通过open()打开的窗口；closed属性检测某窗口是否被关闭；新创建的window对象有一个opener属性，其中保存着打开他的原始窗口对象；这个属性只能在top对象中定义；如果将opener属性设置为null就是告诉浏览器新创建的标签页不需要与打开他的标签页通信，因此可以在独立的进程中运行，标签页之间的联系一旦切断将无法恢复；</p>
    <p>JavaScript是单线程语言，因此一定时间内只能执行一段代码；为了控制要执行的代码就要有一个JavaScript任务队列，这些任务会按照他们添加到队列的顺序执行；但它允许通过设置超时值（setTimeout()）和间歇时间值(setInterval())来调度代码在特定的时间执行；定时器的第二个参数会告诉JavaScript再过多长时间把当前任务添加到队列中；如果队列是空的，那么添加的代码会被立即执行，否则就要等前面的代码执行完了以后再执行；</p>
    <p>往定时器中添加字符串代码可能会导致性能损失；因此不建议以字符串作为第一个参数；建议把函数传递给第一个参数；</p>
    <p>超时调用的代码都是在全局作用域中执行的，因此函数中的this的值在非严格模式下指向window对象，在严格模式下是undefined;</p>
    <p>一般认为使用超时调用来模拟间歇调用的是一种最佳模式；在开发环境下很少使用真正的间歇调用，原因是最后一个间歇调用可能会在前一个间歇调用结束之前启动；而用超时调用模仿间歇调用可以避免这个问题；</p>
    <p>系统对话框与浏览器中显示的网页没有任何关系，也不包含任何的HTML,它的外观由操作系统和浏览器设置决定，而不是由css决定；通过这几个方法打开的对话框都是同步的和模态的；也就是说，显示这些对话框的时候代码会停止执行，而关掉这些对话框后代码又会恢复执行；</p>
    <p>alert()方法：向用户显示一个系统对话框，其中包含指定的文本和一个OK（确定）按钮；</p>
    <p>confirm()方法：向用户显示一个系统对话框，其中包含指定的文本和一个OK（确定）按钮与一个cancel(取消)按钮，并返回一个布尔值；</p>
    <p>prompt()方法：向用户显示一个系统对话框，用于提示用户输入一些文本，接收两个参数--显示给用户的文本提示和文本输入域的默认值；提示框中包含文本输入域、指定的提示文本和一个OK（确定）按钮与一个cancel(取消)按钮；如果用户单击了ok按钮，则返回文本输入域的值；否则返回null;</p>
    <p>location对象提供了与当前窗口中加载的文档有关的信息，还提供了一些导航功能，还可以将URL解析为独立的片段，让开发人员可以通过不同的属性访问这些片段；它既是window对象的属性，也是document对象的属性；</p>
    <pre>
    改变浏览器位置的方法：浏览器中的页面在文件中的层级位置，不是在显示屏上的位置；
        location.assign(URL)；window.location = URL; location.href = url;
        location.replace(url):不生成历史记录，不能后退页面；
        location.reload():如果不给此方法传输参数则从缓存中加载，如果传递参数true则从服务器加载重新页面；
    navigator对象：用于检测显示网页的浏览器类型，版本信息等；
    对于非IE浏览器，可以使用plugins数组来达到这个目的。该数组中的每一项都包含下列属性。
        name:插件名字；
        description:插件的描述；
        filename:插件的文件名；
        length:插件所处理的MIME类型数量；
    对于IE中的插件需要用到ActiveXObject类型实例；
    最终可以将两种检测方法封装成一个函数，这样也方便；
    MIME类型、注册处理程序：疑问P214;
    screen对象：疑问P214;
    history对象保存着用户上网的历史记录，从窗口口被打开的那一刻起；出于安全考虑开发人员无法得知用户浏览过的URL；
        go()方法：可以在用户的历史记录中任意跳转，可以向后也可以向前；可接受一个数值参数；如果接受一个字符串参数的话，则会跳转到历史记录中包含该字符串的第一个位置，可能向前也可能向后；
        back():相当于浏览器的后退按钮；
        forward():相当于浏览器的前进按钮；
    length属性：保存着历史记录的数量；对于第一个页面history.length的值为0，这是历史记录当前的不算；
    <h1>第九章：客户端检测</h1>
    能力检测：又称特性检测，其实就是《编程艺术》中方法属性检测；
    更可靠的能力检测：疑问P218；
    怪癖检测：想要知道浏览器存在什么缺陷；
    用户代理检测：检测大量与浏览器有关的信息；
        用户代理字符串的访问方式：navigator.userAgent属性访问；
        93年第一款浏览器Mosaic,由于当时此浏览器占据着市场的半壁江山，各大浏览器出于兼容性的考虑，都把各自用户代理字符串的名字改为Mosaic；
        Geoko是Firefox的呈现引擎；
        WebKit是KHTML的一个分支，KHTML是Konqueror浏览器的呈现引擎，Konqueror浏览器属于Linux平台；
        WebKit是Safari的呈现引擎；Safari是苹果公司发布的Web浏览器；
        谷歌浏览器也是以WebKit作为呈现引擎，但使用了不同的JavaScript引擎；
        Opera早期的用户代理字符串使用了自己的名称，后期出于兼容也用了Mosaic；
        Presto是Opera的呈现引擎；
        移动操作系统iOS和Android默认的浏览器都基于WebKit呈现引擎；
    有限采用能力检测和怪癖检测，用户代理检测一般用于下列情形：
        不能直接准确地使用能力检测和怪癖检测；列入某些浏览器实现了为将来功能预留的存根函数，此时仅测试相应的函数是否存在还得不到足够的信息；
        同一款浏览器在不同的平台下具备不同的能力，此时就需要检测平台的类型了；
        为了跟踪分析等目的需要知道确切的浏览器；
    <h1>第十章：DOM</h1>
    DOM是针对HTML和XML文档的一个API(应用程序接口);JavaScript对DOM1级的实现。
    IE中所有的DOM对象都是以COM对象的形式实现的；这意味着IE中的DOM对象与原生JavaScript对象的行为或活动特点并不一致；
    文档节点是每个文档的根节点，文档节点只有一个子节点，即&lthtml&gt元素，我们称之为文档元素；每个文档只能有一个文档元素；在HTML页面中，文档元素始终都是html元素；在XML中，没有预定义的元素，因此任何元素都可能成为文档元素；
    DOM1级中定义了一个Node接口，该接口将有DOM中的所有节点类型实现，这个Node接口在JavaScript中是作为Node类型实现的；总共有12种节点类型，这些类型都续承自一个基本类型--Node类型，因此所有节点类型都共享着相同的基本属性和方法；
    由于IE没有公开Node类型的构造函数，所以不支持Node接口模式；为了确保浏览器的兼容，最好将nodeType属性与数字值进行比较；
    nodeName：节点名字属性；nodeValue：节点值属性；
    childNodes:子节点属性，这其中保存着一个NodeList对象，NodeList是一种类数组对象，但不是Array的实例;hasChildNodes():在节点包含一个或多个子节点的情况下返回true;parentNode:父节点属性；
    previousSibling:;nextSibling:;
    ownerDocument属性：该属性指向表示整个文档的文档节点；
    对于元素节点，nodeName中保存的始终都是元素的标签名，而nodeValue的值则始终为null;
    item()方法：访问childNodes集合--NodeList对象的节点的方法，把位置标记当做参数传递；
    将NodeList对象转换为数组的方法：疑问：P250
    parentNode.appendChild():用于向childNode列表的末尾添加一个节点，并返回新增的节点如果传入此方法的节点已经是文档的一部分，那结果就是将该节点从原来的位置转移到新的位置；
    parentNode.insertBefore(要插入的新节点，参照的节点):在某个节点前插入一个新节点，并返回新节点，如果参照节点是null,则会把节点插入到最后一个子节点；
    parentNode.replaceChild(要插入的新节点，被替换的节点):替换文档中的某个节点，要替换的某个节点从文档中移除并通过此方法返回；
    parentNode.removeChild():移除某个节点，并返回被移除的节点；
    cloneNode():赋值某个节点，该方法接收一个布尔值参数，如果是true,则执行深复制--复制节点及其整个子节点；如果是false,则只赋值此节点不复制子节点；
    normalize():用来处理文档树中的文本节点，把文本中的空格删除，把两个文本节点链接到一起,此文本节点的length属性值最终变为1；splitText(count):分隔文本节点的方法，原来的文本节点将包含从开始到指定位置之前的内容，新文本节点将包含剩下的文本；
    JavaScript通过Document类型表示文档。在浏览器中，document对象是HTMLDocument(续承自Document类型)的一个实例，表示整个HTML页面。document对象是window对象的一个属性；document.nodeName的值是“#document”；
    documentElement属性：该属性始终指向HTML页面中的html元素，是document的子节点；
    document.body:直接指向body元素；
    document.doctype:指向&ltDOCTYPE&gt标签；即是DocumentType节点；但是各浏览器对此节点的支持差别很大；
    document.title:title元素的文本；
    与网页请求有关的3个属性：这些信息都存在于请求的HTTP头部，只不过是通过这些属性让我们能过在JavaScript中访问它们而已；
        document.URL:包含网页完整的URL（即地址栏中显示的URL）；
        document.domain:页面的域名，如果两个网页都包含相同的子域名，将网页域名设置为共有的子域名，则两网页之间可以互相访问，但是这个过程不可逆；
        document.referrer:连接到当前页面的URL;
    Document类型为获取特定元素提供了两个方法：
        getElementById():通过id获取元素，如果页面中有多个相同id名的元素则会返回第一个id的元素；
        getElementsByTagName():通过标签名获取元素，返回的是一个NodeList;在Html中会返回一个HTMLCollection对象，该对象与NodeList非常相似，也可以使用item()（数字索引时在后台调用）访问项，此对象也可以通过nameItem()（字符串索引时后台调用）方法获取拥有name属性的元素；如果传入“*”则会获取全部元素；
        getElementsByName():获取带有name特性的元素，常用于input元素，这个方法是HTMLDocument类型才有的方法，会返回一个HTMLCollection对象，nameItem()方法只会返回第一项；
    document对象还有一些特殊的集合，这些集合都是HTMLCollection对象，为访问文档常用的部分提供了快捷方式；
        document.anchors:包含文档中所有带name特性的a元素；
        document.forms:包含文档中所有的form元素；
        document.images:包含文档中所有的img元素；
        document.links：包含文档中所有带href特性的a元素；
    var hasXmlDom = document.implementation.hasFeature('XML','1.0'):返回一个布尔值；
        由于DOM分为多个级别，也包含多个部分，因此检测浏览器实现了DOM的哪些部分就十分中了；
    将输出流写入到网页中的能力：也可以动态包含外部文件；
        write():会原样写入；
        writeln():会在字符串末尾添加一个换行符“\n”；
        open()和close()分别用于打开网页和关闭网页的输出流；
    Element类型：
        nodeName和tagName属性：访问元素标签名的属性；
    HTML元素：
        所有HTML元素都由HTMLElement类型表示，HTMLElement类型直接续承自Element类型；
        className属性:没有将这个属性名命名为class，是因为class是ECMAScript的保留字；
    操作元素属性（特性）的DOM方法主要有三个：属性的名称不区分大小写；根据HTML5规范，自定义属性应该加上data-前缀以便验证；
        getAttribute():获取元素属性；
        setAttribute():设置元素属性；
        removeAttribute():移除元素属性；   
        style属性：当通过getAttribute()访问时，返回的style特性值包含的是CSS文本，而通过属性来访问它则会返回一个对象；
        onclick属性；当在元素上使用时，onclick特性中包含的是JavaScript代码，如果通过getAttribute()访问时，则会返回相应代码的字符串；而通过属性访问时则会返回一个JavaScript函数（如果未在元素中指定相应特性，则会返回null）；
    attributes属性：
        attributes属性包含一个NameNodeMap集合对象，所有的属性节点都保存在这个集合对象中，此对象拥有下列方法：
            getNamedItem(name):返回nodeName属性等于name的节点；
            removeNamedItem(name):从列表中移除nodeName等于name的节点；
            setNamedItem(node):向列表中添加节点，以节点的nodeName属性为索引；
            item(pos):返回位于数字pos位置处的节点；
        var id = element.attributes.getNameItem('id').nodeValue;
        var id = element.attributes["id"].nodeValue;
        element.attributes["id"].nodeValue = "newValue";
    document.createElement():创建新元素的方法；
    Text类型：
        nodeName的值为“#text”；
        nodeValue和data属性：访问Text节点中包含的文本；
        appendData(text):将text添加到节点的末尾；
        deleteData(offset,count):从offset指定的位置开始删除count个字符；
        insertData(offset,text):在offset指定位置插入text;
        replaceData(offset,count,text):用text替换从offset指定位置到offset+count为止处的文本；
        splitText(offset):从offset指定位置将当前文本节点分成两个文本节点；
        substringData(offset,count):提取从offset指定的位置开始到offset+count为止处的字符串；
    document.createTextNode():创建文本节点，如果将相邻的两个文本节点插入元素，则会链接起来显示；
    Comment类型：注释在DOM中是以此类型来表示的；
        document.createComment():创建注释文本节点；
        此类型节点不拥有splitText()方法；
    CDATASection类型：此节点类型是基于XML文档中的Comment类型；续承自Text类型，但是此类型节点不拥有splitText()方法；
    DocumentType类型：
        此类型包含着与文档的doctype有关的所有信息；
        nodeName的值为doctype的名称；
        name属性：表示文档类型的名称；
    DocumentFragment类型：文档片段，即文档碎片；此方法相对于声明变量来存储数据可能更节约内存空间；
        var fragment = document.createDocumentFragment();
    Attr类型：
        元素的特性在DOM中以Attr类型来表示。特性就是存在于元素的attributes属性中的节点；
        name属性：是特性名称（与nodeName的值相同）；
        value属性：特性的值（与nodeValue的值相同）；
        specified:是一个布尔值，用以区别特性是在代码中指定的，还是默认的；
        document.createAttribute("attr"):创建特性节点；
        setAttributeNode("attr"):将新创建的特性添加到元素中；
    动态脚本：在HTML文档中不用标签引入外部JS文件，而是用JS代码引入外部文件和内嵌JS文本；动态添加样式是同样的道理；
    操作表格：由于使用Core DOM方法创建、操作表格往往需要编写大量的代码；为了更为方便的构建表格，HTML DOM还为表格元素添加了一些属性和方法：
        为&lttable&gt元素添加的属性和方法如下：
            caption:保存着对&ltcaption&gt元素的指针；
            tBodies:是一个&lttbody&gt元素的HTMLCollection;
            tFoot:保存着对&lttfoot&gt元素的指针；
            tHead:保存着对&lttHead&gt元素的指针；
            rows：是一个表格中所有行的HTMLCollection;
            createTHead():创建&ltthead&gt元素，将其放到表格中，返回引用；
            createTFoot():创建&lttfoot&gt元素，将其放到表格中，返回引用；
            createCaption():创建&ltcaption&gt元素，将其放到表格中，返回引用；
            deleteTHead():删除&ltthead&gt元素；
            deleteTFoot():删除&lttfoot&gt元素；
            deleteCaption():删除&ltcaption&gt元素；
            deleteRow(pos):删除指定位置的行；
            insertRow(pos):向rows集合中的指定位置插入一行；
        为&lttbody&gt元素添加属性和方法如下；
            rows:保存着&lttbody&gt元素行的HTMLCollection;
            deleteRow(pos):删除指定位置的行；
            insertRow(pos):向rows集合中的指定位置插入一行，返回新插入的行的引用；
        为&lttr&gt元素添加的属性和方法：
            cells:保存着&lttr&gt元素中单元格的HTMLCollection;
            deleteCell(pos):删除指定位置的单元格；
            insertCell(pos):向cells集合中的指定位置插入一格单元格，返回新插入的单元格的引用；
    <h1>第十一章：DOM扩展</h1>
    Selectors API Level 1 的核心有两个方法：
        querySelector():接收一个CSS选择符，返回与该模式匹配的第一个元素，如果没有找到匹配元素，则会返回null;
        querySelectorAll():接收一个CSS选择符，返回与该模式匹配的所有元素，而不是一个元素，这个方法返回的是一个NodeList的实例；可以通过item()方法或者方括号语法来访问NodeList中的每一个元素；
    matchesSelector()方法：如果调用元素与该选择符匹配，返回true；否则返回false;
    元素遍历：
        childElementCount:返回子元素的个数；
        firstElementChild:指向第一个子元素；firstChild的元素版；
        lastElementChild:指向第一个子元素；lastChild的元素版；
        previousElementSibling:指向前一个同辈元素；previousSibling元素版；
        nextElementSibling:指向后一个同辈元素；nextSibling元素版；
    getEkementsByClassName():通过类名获取元素；传入多个类名时，类名的先后顺序不重要，表示同时具有有个类名的元素；
    classList属性：此属性是新集合类型DOMTokenList的一个实例；div.classList.remove("user");
        add(value):将给定的字符串值添加到列表中；
        contains(value):表示列表中是否存在给定的值，如果存在则返回true,否则返回false;
        remove(value):从列表中删除给定的字符串；
        toggle(value):把value在列表中进行切换；
    焦点管理：
        document.activeElement属性：会引用DOM中当前获得焦点的元素；文档加载期间此属性为null,默认情况下文档刚刚加载完成时，此属性中保存的是document.body元素；
        document.hasFocus()方法：用于确定文档是否获得了焦点；
    readyState属性的两个值：
        loading:正在加载文档；
        complete:已经加载完文档；
    document.compatMode属性：获取浏览器渲染文档的模式，此属性有两个值；
        CSS1Compat:标准模式；
        BackCompat:混杂模式；
    document.body属性：引用head元素的属性；
    document.charset:设置字符集的属性；默认值为UTF-16;defaultCharset属性：默认字符集的值，与浏览器和操作系统有关；
    自定义数据属性：
        H5规定可以为元素添加非标准的属性，但要添加前缀data-,目的是为元素提供与渲染无关的信息，或者提供语义信息；
        dataset属性：获取自定义属性的值；dataset属性的值是DOMStringMap 的一个实例，是一个名值对的映射；div.dataset.name;
    innerHTML属性：操作调用元素的所有后代节点，此属性可以解析html文档标签；   
    outerHTML属性：操作调用元素本身以及所有后代节点，此属性可以解析html文档标签；
    insertAdjacentHTML()方法：插入标记的方法；
        此方法接收两个参数--插入的位置和要插入的HTML文本；
        “beforebegin”:在当前元素之前插入一个紧邻的同辈元素；
        “afterbegin”:在当前元素之下插入一个新的子元素或者在第一个子元素之前再插入新的子元素；
        “beforeend”；在当前元素之下插入一个新的子元素或者在第一个子元素之后再插入新的子元素；
        “afterend”:在当前面元素之后插入一个紧邻的同辈元素；
    scrollIntoView()方法：窗口滚动方法；作用对象是元素的容器；
        如果参数是true,或者不传入参数，会与顶部对齐；
        如果参数是false,调用元素会尽可能的展现在视野中，可能与底部对齐；
    scrollIntoViewIfNeeded(aligncenter)方法：作用对象是元素的容器；
        只有在当前元素在视野中不可见的情况下，才滚动浏览器窗口或容器元素，最终让他可见；如果当前元素在视口中可见，这个方法什么也不做；如果将可选的alignCenter参数设为true,则表示将当前元素显示在视口中部（垂直方向）；
    scrollByLines(lineCount):将元素的内容滚动指定的页面高度，lineCount值可以是正值也可以是负值；作用对象是元素本身；
    scrollByPages(pageCount):将元素内容滚动到指定的页面高度，具体高度由元素的高度决定；作用对象是元素本身；
    要强制浏览器以某种模式渲染页面，可以使用HTTP头部信息X-UA-Compatible,或者通过等价的&ltmeta&gt标签来设置：&lt meta http-equiv="X-UA-Compatible" content="IE=IEVersion"&gt
    document.documentMode属性：获取文档模式的属性；
    children属性：是HTMLCollection的实例，只包含元素中同样还是元素的子节点；
    contains()方法：检测调用元素是否包含某一节点；
    compareDocumentPosition():检测两元素之间的关系，返回一个表示该关系的位掩码；
        1：无关；
        2：居前；
        4：居后；
        8：包含；
        16：被包含；
    innerText属性：操作元素中包含的所有文本内容，包含子文档树中的文本；
    outerText属性：操作调用元素中及其本身包含的所有文本内容，包含子文档树中的文本；
    <h1>第十二章：DOM2和DOM3</h1>
    由于HTML不支持XML命名空间，但XHTML支持XML命名空间，因此本节给出的都是XHTML的示例；
    命名空间要使用xmlns特性来指定，将其包含在&lthtml&gt元素中；
    &ltxhtml:html xmlns:xhtml="http://www.w3.org/1999/xhtml"&gt
        &ltxhtml:head&gt
        &lt/xhtml:head&gt
        &ltxhtml:body xhtml:class="home"&gt
        &lt/xhtml:body&gt
    &lt/xhtml:html&gt
    在DOM2级中，node类型包含下列特定于命名空间的属性：
        localName:不带命名空间前缀的节点名称；
        namespaceURL:命名空间URL或者null;
        prefix:命名空间前缀或者null;
        document.body.isSupported(特性名，特性版本号)：判断是否能够支持相应的特性名和特性版本号，与命名空间无关；
        isSameNode()：检测两个节点的类型是否是一个对象；isEqualNode():检测两个节点的类型是否相同，且属性相等；
    在DOM2级中，Document类型包含下列特定于命名空间的方法：    
        createElementNS(namespaceURL,tagName):使用给定的tagName创建一个属于命名空间namespaceURL的新元素；
        createAttributeNS(namespaceURL,attributeName):使用给定的attributeName创建一个属于命名空间namespaceURL的新特性；
        getElementsByTagNameNS(namespaceURL,tagName):返回属于命名空间namespaceURL的tagName元素的NodeList;
    在DOM2级中，Element类型包含下列特定于命名空间的方法：
        getAttributeNS(namespaceURL,localName):取得属于命名空间namespaceURL且名为localName的特性；
        getAttributeNodeNS(namespaceURL,localName):取得属于命名空间namespaceURL且名为localName的特性节点；
        getElementsByTagNameNS(namespaceURL,tagName):返回给定命名空间namespaceURL的tagName元素的NodeList;
        hasAttributeNS(namespaceURL,localName):确定当前元素是否有一个名为localName的特性，而且该特性的命名空间是namespaceURL。
        removeAttributeNS(namespaceURL,localName):删除属于命名空间namespaceURL且名为localName的特性；
        setAttributeNS(namespaceURL,qualifiedName,value):设置属于命名空间namespaceURL且名为qualifiedName的特性的值为value;
        setAttibuteNodeNS(attNode):设置属于命名空间namespaceURL的特性节点；
    在DOM2级中，DocumentType类型；publicId和systemId表示文档类型声明中的两个信息段；internalSubset:用于访问包含在文档类型声明的额外定义；
        var doctype = document.implementation.createDocumentType(文档类型，publicId,systemId):创建一个新的DocumentTyp节点；
        var doc = document.implementation.createDocument(namespaceURL,文档元素的标签名，新文档的文档类型)：创建一个新的文档；
        var htmldoc = document.implementation.createHTMLDocument(title元素中的字符串)：创建一个完整的HTML文档；
    在DOM2级中，Document类型的变化；
         importNode(oldNode,是否复制子节点的布尔值):此方法的用途是从一个文档中取得一个节点，然后将其导入到另一个文档，使其成为这个文档的一部分；
    DOM2级视图：
        defaultView属性：其中保存着一个指针，指向拥有给定文档窗口的窗口或者框架，即确定文档的归属窗口（IE中的parentWindow与此属性相同作用）；
    iframe.contentDocument属性：此属性包含一个指针，指向表示框架内容的文档对象；contentWindow属性于此属性同等作用且所有浏览器支持；
    在DOM3级的有关命名空间的方法：
        isDefaultNamespace(namespaceURL):在指定的namespaceURL是当前节点的默认命名空间的情况下返回true；
        lookupNamespaceURL(prefix):返回给定前缀的命名空间；
        lookupPrefix(namespaceURL):返回给定namespaceURL的前缀；
    setUserData(要设置的键，实际的数据，处理函数):将数据指定给节点；处理函数接收5个参数，表示操作类型的数值（1表示赋值，2表示导入，3表示删除，4表示重命名）、数据键、数据值、源节点和目标节点；用getUserData(键名)获取键的值；
        <h4>访问元素样式：</h4>
    任何支持style特性的HTML元素在JavaScript中都有一个对应的style属性；此属性包含着通过HTML特性指定的所有样式信息，但不包含与外部样式表或嵌入样式表经层叠而来的样式；
    对于短划线的属性需要将其转化为驼峰大小写形式才能通过JavaScript来访问；由于float是JavaScript中的保留字，因此不能用作属性名，因此需要通过cssFloat属性来访问此属性（IE支持styleFloat）；
    DOM样式属性和方法：
        cssText:访问到style特性中的CSS代码；
        length:应用给元素的CSS属性的数量；
        parentRule:表示CSS信息的CSSRule对象；
        getPropertyCSSVlue(propertyName):返回包含给定属性值的CSSValue对象；是一个包含两个属性的CSSValue对象，这两个属性分别是cssText和cssValueType(0表示续承的值，1表示基本的值，2表示值列表，3表示自定义的值；);
        getPropertyPriority(propertyName):如果给定的属性使用了！important设置，则返回“important”;否则返回空字符串；
        getPropertyValue(propertyName):返回给定属性的字符串值；
        item(index):返回给定位置的CSS属性的名称；
        removeProperty(propertyName):从样式中删除给定属性；
        setProperty(propertyName,value,priority):将给定属性设置为相应的值，并加上优先级标志（“important”或者一个空字符串）；
    <h4>计算的样式</h4>
    document.defaultView.getComputedStyle(mydiv,null):获取计算后的样式，第二个参数如果不需要伪元素字符串则为null;在获取综合属性时不一定会返回值，但是却可以把综合属性分开来获取；在IE中currentStyle属性与此方法的作用类似，包含当前元素全部计算后的样式；所有计算属性都是只读的；
    CSSStyleSheet类型表示的是样式表，包括通过link元素包含的样式表和在style元素中定义的样式表；CSSStyleSheet对象则是一套只读接口，续承自StyleSheet，CSSStyleSheet对象从StyleSheet接口续承来的属性如下：
        disabled:表示样式是否被禁用的布尔值，可读写的，true表示禁用样式表；
        href:如果样式表是通过link包含的，则是样式表的URL;否则是null;
        media:当前样式表支持的所有媒体类型的集合。如果集合是空的则表示适用于所有媒体；
        ownerNode:指向拥有当前样式表的节点的指针；如果当前样式表是通过其他样式表通过@import导入的，则这个值为null;
        parentStyleSheet:在当前样式表通过@import导入的情况下，这个属性是一个指向导入他的样式表的指针；
        title:ownerNode中title属性的值；
        type:表示样式表类型的字符串；
    CSSStyleSheet类型还支持下列属性：IE都不支持以下的几个属性；
        cssRules:样式表中包含的样式规则的集合；IE中的rules属性与此属性类似；P318
        ownerRule:如果样式表是通过@import导入的，这个属性就是一个指针，指向表示导入的规则；否则，值为null;
        deleteRule(index):删除cssRules集合中的指定位置的规则；IE中是removeRule()方法；
        insertRule(rule,index):向cssRules集合中指定的位置插入rule字符串；IE中是addRule()方法；
    应用于文档的所有样式表是通过document.styleSheets集合来表示的；   
    <h4>元素大小</h4>
    偏移量：都是只读的；
        offsetHeight:元素在垂直方向上占用的空间大小；
        offsetWidth:元素在水平方向上占用的空间大小；
        offsetLeft:元素的左外边框至包含元素的左内边框之间的像素距离；
        offsetTop:元素的上外边框至包含元素的上内边框之间的像素距离；
        offsetparent属性：包含元素的引用；
    客户区大小：指的是元素内容及其内边距所占空间的大小；只读的；
        clientWidth:客户区水平方向的大小；
        clientHeight:客户区垂直方向的大小；
    滚动大小：指的是包含滚动内容的元素的大小；
        scrollHeight:在没有滚动条的情况下，元素内容的总高度（元素内容的实际大小）；
        scrollWidth:在没有滚动条的情况下，元素内容的总宽度（元素内容的实际大小）；
        scrollLeft:被隐藏在内容区域左侧的像素数，通过设置这个属性可以改变元素的滚动位置；
        scrollTop:被隐藏在内容区域上侧的像素数，通过设置这个属性可以改变元素的滚动位置；
    getBoundingClientRect()方法：此方法返回一个矩形对象，包括4个属性--left、top、right、bottom;
    <h4>遍历</h4>
    以下两个类型能够基于给定的起点对DOM结构执行深度优先的遍历操作；
        NodeIterator类型:P328
            可以用document.createNodeIterator(root,whatToShow,filter/null,是否扩展实体引用的布尔值)方法创建它的新实例；这个参数的值以常量形式在NodeFilter类型中定义；
            nextNode():向前前进一部；
            previousNode():向后后退一部；
        TreeWalker:通过document.createTreeWalker(root,whatToShow,filter/null,是否扩展实体引用的布尔值)方法创建对象；能够在DOM结构中沿任何方向移动遍历；
            nextNode():向前前进一部；
            previousNode():向后后退一部；
            parentNode():遍历到到当前节点的父节点；
            firstChild():遍历到当前节点的第一个子节点；
            lastChild():遍历到当前节点的最后一个子节点；
            nextSibling():遍历到当前节点的下一个同辈节点；
            previousSibling():遍历到当前节点的上一个同辈节点；
            currentNode属性：表示任何遍历方法在上一次遍历中返回的节点，用来修改继续遍历的起点；
    <h4>范围</h4>P332
    document.createRange()方法：创建DOM的方法；
    每个范围由一个Range类型的实例表示，这个实例拥有很多属性和方法，下列属性提供了当前范围在文档中的位置信息；
        startContainer:包含范围起点的节点（即选区中第一个节点的父节点）；
        startOffset:范围在startContainer中起点的偏移量；
        endContainer:包含范围终点的节点（即选区中最后一个节点的父节点）；
        endOffset:范围在endContainer中终点的偏移量；
        commonAncestorContainer:startContainer和endContainer共同的祖先节点在文档中位置最深的那个；
    selectNode():选择整个节点，包括其子节点；
    selectNodeContents():只选择节点的子节点；
    setStartBefore(refNode):将范围的起点设置在refNode之前；
    setStartAfter(refNode):将范围的起点设置在refNode之后；
    setEndBefore(refNode):将范围的终点设置在refNode之前；
    setEndAfter(refNode):将范围的终点设置在refNode之后；
    setStart(参照节点，偏移量):
    setEnd(参照节点，偏移量):
    deleteContents():删除范围所包含的内容；
    extractContents():删除范围所包含的内容,并返回所删除的内容；
    cloneContents():创建一个范围对象副本；
    insertNode():向范围选区的开始处插入一个节点；
    surroundContents():环绕范围插入内容；
    collapsed(true/false):折叠范围的方法，参数true表示折叠到起点，参数false表示折叠到终点；collapsed属性表示是否折叠完毕；
    compareBoundaryPoints(比较方式的常量，比较范围)：来确定这些范围是否有公共的边界；返回代表关系的-1/0/1；
    cloneRange():复制范围副本；
    detach():清理DOM范围；
    <h4>第十三章：事件</h4>
    事件流描述的是从页面中接收事件的顺序--事件冒泡流和事件捕获流；也就是同一类事件在包含元素和不包含元素的触发顺序；
    事件捕获的用意在于在事件到达预定目标之前捕获他；尽管“DOM2级事件”规范要求事件应该从document对象开始传播，但这些浏览器都是从window对象开始捕获事件的；
    “DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段；
    click是事件的名字，onclick是事件的事件处理程序（或事件侦听器）；
    由于内嵌的事件处理函数值不能是未经转义的HTML语法字符，例如和号（“\&”）、单双引号、大于号小于号；在内嵌的事件处理函数值中也可以直接访问元素的属性；
    给元素添加事件的方法：DOM中存在的事件对象event;
        元素内嵌式；onclick = "alert(event.type)";event是变量；
        DOM0级事件处理程序：向元素对象的事件属性赋值式；此种方式添加的事件处理程序会在事件流的冒泡阶段被处理；btn.onclick=null,删除事件处理程序;
        DOM2级事件处理程序：addEventListener(事件名，事件函数，捕获true/冒泡false),此方法可以添加多个事件处理程序，通过此方法添加的事件只能通过removeEventListenter(事件名，事件函数，捕获true/冒泡false)移除，但是没法移除匿名函数;IE中是attachEvent(on事件名，事件函数)和detachEvent(on事件名，事件函数)且作用域是全局作用域，执行顺序相反;
    本书将使用EventUtil对象来处理浏览器之间的差异，此对象有一个方法addHandler(要操作的元素，事件名，事件函数)，removeHander(要操作的元素，事件名，事件函数);
    currentTarget属性是目标元素，是不会变得；target属性是事件处理程序触发的元素，会受冒泡或捕获影响而改变的；
    UI事件：是指那些不一定与用户操作有关的事件；
        unload:卸载事件；
        abort:当用户停止下载过程时，如果嵌入的内容没有加载完，则在object元素上触发；
        error:报错事件；
        select:当用户选中文本框时触发；
        resize:当窗口发生变化时在window上触发；
        scroll:当用户滚动带滚动条的元素时触发；
    通过JavaScript创建的图像元素不一定从添加到文档后才开始下载，只要设置了src属性就会开始下载；只有在设置了script元素的src属性并将该元素添加到文档后才开始下载JavaScript文件；
    焦点事件：
        document.hasFocus()方法：
        document.activeElement属性：
        blur：在元素失去焦点时触发，此事件不会冒泡；
        focus:在元素获得焦点时触发，此事件不会冒泡；
        focusin:在元素获得焦点时触发，此事件会冒泡；
    鼠标事件：
        click:单击主鼠标事件或者按下回车时触发；
        dbclick:在用户双击主鼠标按钮时触发；
        mousedown:在用户按下任意鼠标按钮时触发；无法键盘触发；
        mouseup:在用户释放鼠标按钮时触发；无法键盘触发；
        mouseenter:在鼠标光标首次从元素外部移动到元素范围之内时触发；不冒泡不捕捉；
        mouseleave:在鼠标光标首次从元素内部移动到元素范围之外时触发；不冒泡不捕捉；
        mousemove:在鼠标指针在元素内部移动时重复的触发；不能键盘触发；
        mouseout:在鼠标指针位于一个元素上方，然后用户将其移入另一个元素时触发。又移入的另一个元素可能位于前一个元素的外部，也可能是这个元素的子元素；
        mouseover:在鼠标指针位于一个元素外部，然后用户将其首次移入另一个元素边界之内时触发。又移入的另一个元素可能位于前一个元素的外部，也可能是这个元素的子元素；
        mousewheel:鼠标滚轮事件；wheelDelta属性是120的倍数；
    坐标位置属性：
        clientX:浏览器视口的水平位置坐标；clientY:浏览器视口的垂直位置坐标；
        pageX:页面的水平位置坐标；pageY:页面的垂直位置坐标；
        screenX:屏幕的水平位置坐标；screenY:屏幕的垂直位置坐标；
    修改键属性：shiftKey、ctrlKey、altKey和metaKey的值为true表示按键被按下；
    鼠标按钮：DOM中的button属性有三个值--0表示主鼠标按钮、1表示中间的鼠标滚动按钮、2表示次鼠标按钮；IE中有8个值；
    detail属性：用于给出有关事件的更多信息，DOM2中；
        对于鼠标事件此属性包含了在给定位置上发生了多少次单击；
    键盘事件：
        keydown:当用户按下键盘上的任意键时触发，而且如果按住不放的话，会重复触发此事件；
        keypress:当用户按下键盘上的字符键时触发，而且如果按住不放的话，会重复触发此事件；
        keyup:当用户释放键盘上的键时触发；
        textInput:在文本插入文本框之前会触发textInput事件，用意是在将文本显示给用户之前更容易拦截文本；even.data属性是用户输入的字符；
    键码：
         keyCode属性：包含键盘上特定按键的键码；
         charCode属性：字符的ASCII编码；String.fromCharCode()将其转化为实际的字符；
    变动事件：在DOM中的某一部分发生变化时给出提示；
        DOMSubtreeModified:在DOM结构中发生任何变化时触发，这个事件在其他任何事件触发后都会触发；a3 b3
        DOMNodeInserted:在一个节点作为子节点被插入到另一个节点中时触发；b1
        DOMNodeInsertedIntoDocument:在一个节点被插入到文档或者通过子树间接插入文档之后触发。这个事件在DOMNodeInserted之后触发；b2
        DOMNodeRemoved:在节点从其父节点中被移除时触发；a1
        DOMNodeRemovedFromDocument:在一个节点被直接从文档中移除或通过子树间接从文档中移除之前触发。这个事件在DOMNodeRemoved之后触发；a2
        DOMAttrModified:在特性被修改之后触发；
        DOMCharacterDataModified:在文本节点的值发生变化时触发；
    HTML5事件：
        contextmenu事件：鼠标右键菜单键；
        beforeunload:页面卸载之前触发；为了显示弹出对话框，必须将event.returnValue的值设置为要显示给用户的字符串，同时作为函数的值返回；
        DOMContentLoaded:在加载完DOM树时就触发，不理会图像、JS文件和CSS文件或其他资源是否下载完毕；
        readystatechange事件：此事件的目的与文档或元素的加载状态有关的信息；此事件的每个对象都有一个readyState属性，此属性包含下列5个值：
            uninitialized:对象存在但尚未初始化；
            loading:对象正在加载数据；
            loaded:对象加载数据完成；
            interactive:可以操作对象了。但还没有完成加载；
            complete:对象已经加载完毕；
        pageshow事件：
            这个事件在页面显示时触发，无论这个页面是来自bfcache还是来自加载；此事件的event对象包含一个属性persisted的布尔值；如果页面被保存在了bfcache中，此属性为true;否则为false;
        pagehide事件：
            该事件会在浏览器卸载页面时触发，而且是在unload事件之前触发；如果页面卸载时被保存在bfcache中，则此事件的event对象包含一个属性persisted的布尔值为true;onunload事件卸载的页面会自动排除在bfcache之外；
        hashchange事件：
            当URL参数列表发生变化时触发（#号后的字符），有一个localtion属性；
        orientationchange事件：
            横竖向查看模式切换事件；包含三个值0/90/-90；
    触摸事件：
        touchstart:当手指触摸屏幕时触发，即使已经有一个手指放在了屏幕上也会触发；
        touchmove:当手指在屏幕上滑动时连续触发，在这个事件发生期间，调用preventDefault()可阻止滚动；
        touchend:当手指从屏幕上移开时触发；
        touchcancel:当系统停止跟踪触摸时触发；
        触摸事件的属性：
            touchs:表示当前跟踪的触摸操作的Touch对象的数组；
            targetTouchs:特定于事件目标的Touch对象的数组；
            changeTouches:表示自上次触摸以来发生了什么改变的Touch对象的数组；
            identifier:标识触摸的唯一ID;
            target:触摸的DOM节点目标；
    手势事件：
        gesturestart:当一个手指已经按在屏幕上而另一个手指又触摸屏幕时触发；
        gesturechange:当触摸屏幕的任何一个手指的位置发生变化时触发；
        gestureend:当任何一个手指从屏幕上面移开时触发；
        手势事件的特有属性：
            rotation:表示手指变化引起的旋转角度；
            scale:表示两手指间距离的变化情况；
    事件委托：
        是“事件处理程序过多”问题的解决方案；
        利用了事件的冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件；
    移除事件处理程序：btn.onclick=null;
    模拟事件：
        事件就是网页中某个特别值得关注的瞬间，事件经常由用户操作或通过其他浏览器功能来触发。但很少有人知道，也可以使用JavaScript在任意时刻来触发特定的事件，而此时的事件就如同浏览器创建的事件一样；
        var event = document.createEvent():创建even对象的方法；此方法有四种参数可选：
            UIEvents:一般化的UI事件，DOM3级中是单数；
            MouseEvents:一般化的鼠标事件，DOM3级中是单数；
            MutationEvents:一般化的DOM变动事件，DOM3级中是单数；
            HTMLEvents:一般化的HTML事件；
        event.initMouseEvent():初始化事件对象；有15个参数；
        btn.dispatchEvent(event)：触发事件；
    自定义DOM事件：
        var event = document.createEvent(“CustomEvent”):创建自定义事件的方法；此方法有四种参数可选：
        event.initCustomEvent("myevent",是否冒泡，是否可取消，详细信息)：初始化自定义事件；
        div.dispatchEvent(event):触发自定义事件；
    <h4>第十四章：表单脚本</h4>
    HTMLFormElement独有的属性和方法：
        acceptCharset:服务器能够处理的字符集；
        action:接收请求的URL;
        elements:表单中所有控件的集合--HTMLCollection;
        enctype:请求的编码类型；
        length:表单中控件的数量；
        method:要发送的HTTP类型，通常是get或post;
        name:表单或者表单字段的名称；如果有多个表单控件都在使用一个name（如单选按钮），把name值当做索引名，那么就会返回以该name命名的一个NodeList。如果把name名当做表单属性则会获得第一个表单字段；
        reset():所有表单重置为默认值；此方法会触发reset事件；
        submit():提交表单；用此方法提交表单时不会触发submit事件；
        target:用于发送请求和接收响应的窗口名称；
    取得form元素引用的方法：
        通过ID获取；
        通过document.forms可以取得页面中所有的表单；在这个集合中，可以通过数值索引或name值取得特定的表单；
    表单字段共有的属性：
        disabled:布尔值，表示当前字段是否被禁用；
        form:指向当前字段所属的指针；只读；
        name:当前字段的名称；
        readOnly:布尔值，表示当前字段是否只读；
        tabIndex:表示当前字段的切换（tab）序号；如果将非表单元素的此属性设置为-0，再调用focus()方法，也可以让非表单元素获得焦点；
        type:表示当前字段的类型；
        value:当前字段被提交给服务器的值；
        autofocus属性：自动获取焦点属性，布尔值；
    共有的表单字段事件：
        blur:当字段失去焦点时触发；focus:当前字段获得焦点时触发；
        change:对于input和textarea元素，在他们失去焦点且value值改变时触发，对于select元素，在其选项改变是触发；
    select()方法：对于input和textarea元素，这个方法用于选择文本框中所有的文本； 
    select事件：在文本框选中文本时就会触发此事件；
    selectionStart和selectionEnd属性：表示所选择文本的范围，作为substring()的参数；
    setSelectionRange(开始的索引，结束的索引)方法：选择部分文本；
    剪贴板事件：
        beforecopy:在发生复制操作前触发；
        copy:在发生复制操作时触发；
        beforecut:在发生剪切操作前触发；
        cut:在发生剪切操作时触发；
        beforepaste：在发生粘贴操作前触发；
        paste:在发生粘贴操作时触发；
        clipboardData对象：要访问剪切板中的数据需要用的对象；此对象有三个方法：
            getData():获取剪切版数据，参数是要取得的数据格式；
            setData():设置剪切板数据，第一个参数是数据类型，第二个参数是要放在剪切板中的文本；
            clearData():清除剪切板数据；
    输入模式：
        H5中新增了pattern属性，用于匹配文本框中的值；
    检测有效性：
        checkValidity()方法：可以检测表单或者表单中的某个字段是否有效，是个布尔值；如果必填字段没有值为无效的，而字段中的值与pattern属性不匹配也是无效的；表单中所有表单字段中有一个字段无效都会返回false;
        与checkValidity()方法简单地告诉你字段是否有效相比，validity属性则会告诉你为什么字段有效或无效。这个对象中包含了一系列属性，每个属性都会返回一个布尔值。P430
    novalidate属性：通过设置此属性，可以告诉表单不进行验证；formnovalidate属性为了指定某个提交按钮不必验证表单；
    HTMLSelectElement类型还提供了下列属性和方法：
        add(newOption,relOption):向relOption向之前插入option元素；
        multiple:布尔值，表示是否允许多项选择；
        options：控件中所有option元素的HTMLCollection;
        remove(index):移除给定位置的选项；将相应的选项设置为null也可以移除相应的选项；
        selectedIndex:基于0的选中项的索引，如果没有选中项，则值为-1。对于支持多选的控件，只保存选中项中的第一项的索引；
        size：选择框中可见的行数；
    选择框中的type属性是“select-one”和"select-multiple";如果option元素没有value特性，则value属性的值是文本；如果value特性是空值，则是是空字符串；如果有两个选中项则是第一个option元素；
    在DOM中，每个option元素都有一个HTMLOptionElement对象表示，为了便于访问数据，HTMLOptionElement对象添加了下了属性：
        index:当前选项在options集合中的索引。
        lable:当前选项的标签；等价于HTML中的lable特性；
        selected:布尔值，表示当前选项是否被选中。将这个属性设置为true可以选中当前选项；
        text:选项的文本；
        value:选项的值；
    富文本编辑：即是所见即所得；
        这一技术的本质，就是在页面中嵌入一个包含空HTML页面的iframe.通过设置designMode属性，这个空白的HTML页面可以被编辑，而编辑对象则是该页面body元素的HTML代码。designMode属性有如果设置为on，则整个文档都会变成可以编辑；
        contenteditable属性：把这个属性用在页面中的任何元素，然后就可以编辑这个元素了；此属性有三个值：true:打开；false:关闭；inhert：从父元素那里续承；
    操作富文本：
        document.execCommand():是与富文本编辑器交互的主要方式；此方法有三个参数：要执行的命令名称、表示浏览器是否应该为当前命令提供用户界面的一个布尔值和执行命令必须的一个值；
    <h4>第15章：使用Canvas绘图</h4>
    在Canvas上绘图，需要取得绘图上下文。而取得绘图上下文对象的引用，需要调用getContext()方法并传入上下文的名字。传入“2d”,就可以取得2D上下文对象；
    toDataURL("image/png")方法：可以导出在canvas元素上绘制的图像；
    fillStyle属性：填充；strokeStyle属性：描边；lineWidth属性：线条的宽度；lineCap属性：线条末端的形状--butt/平头、round/圆头和square/方头；lineJoin属性：线条相交的方式--圆交/round、斜交/bevel、斜接/miter;
    与绘制矩形有关的方法：这三个方法都接收四个参数--矩形的X坐标、矩形的y坐标、矩形的宽度和高度；
        fillRect():
        strokeRect():
        clearRect():
    绘制路径：
        beginPath():绘制路径的开始；
        arc(x,y,radius,startAngle,endAngle,counterclockwise):绘制圆的方法，最后一个参数是表示是否按逆时针方向计算，false时表示顺时针方向；
        arcTo(x1,y1,x2,y2,radius):从上一点开始绘制一条弧线，到(x2,y2)为止，并且以给定的半径radius穿过(x1,y1)。
        bezierCurveTo(c1x,c1y,c2x,c2y,x,y)：从上一点开始绘制一条曲线，到(x,y)为止，并以(c1x,c1y)和(c2x,c2y)为控制点。
        lineTo(x,y):从上一点开始绘制一条直线，到(x,y)为止。
        moveTo(x,y):将绘图游标移动到(x,y),不划线；
        quadraticCurveTo(cx,cy,x,y):从上一点开始绘制一条二次曲线，到(x,y)为止，并且以(cx,cy)作为控制点。
        rect(x,y,width,height):从点(x,y)开始绘制一个矩形路径，需要描边；
        closePath():把路径和起点链接，结束路径；
        fill():填充绘制的路径；
        stroke():对绘制的路径进行描边；
        clip():对绘制的路径进行剪切；
        isPointInPath(x,y):在路径关闭前确定此点是否在路径上；
    绘制文本：这两个方法接收四个参数--要绘制的文本字符串、x坐标、y坐标和可选的最大像素宽度；
        fillText():
        strokeText():
            font:表示文本的样式、大小和字体；
            textAlign:表示文本的对齐方式；
            textBaseline:表示文本的基线；
            measureText("要绘制的文本")：返回一个TextMetrics对象，此对象只有一个width属性；
    变换：
        rotate(angle):围绕原点旋转图像angle弧度；
        scale(x,y):缩放图像；
        translate(x,y):将坐标原点移动到（x,y）执行这个变换后，坐标（0,0）会变成之前由（x,y）表示的点；
        transform(m1_1,m1_2,m2_1,m2_2,dx，dy):直接修改变换矩阵；
        setTransform(m1_1,m1_2,m2_1,m2_2,dx,dy):将变换矩阵重置为默认状态，然后再调用transform();
    save():将所有设置保存在一个栈结构中；
    restore():将保存的栈结构返回一级；
    drawImage(img,imgX,imgY,imgWidth,imgHeight,目标图像的x坐标,目标图像的y坐标,目标图像的宽度,目标图像的高度):在画布上操作图片，但是要绘制的图片不能来自其他域；
    阴影：这些属性需要通过context对象在绘制前来修改；
        shadowColor:设置阴影的颜色；
        shadowOffsetX:形状或路径x轴方向的阴影偏移量；
        shadowOffsetY:形状或路径y轴方向的阴影偏移量；
        shadowBlur:模糊的像素数；
    渐变：
        gradient.createLinearGradient(起点的x坐标,起点y的坐标,终点的x坐标,终点y的坐标)方法：创建线性渐变的方法；
        gradient.addColorStop(色标位置,css颜色值)方法：创建渐变色色标；
        context.fillStyle = gradient:绘制填充矩形；
        createRadialGradient(起点圆的圆心X坐标,起点圆的圆心Y坐标,起点圆半径R,终点圆的圆心X坐标,终点圆的圆心Y坐标,终点圆半径R):创建放射渐变（径向渐变）的方法；
        pattern = context.createPattern(image/video/canvas,"repeat/repeat-x/repeat-y/no-repeat"):创建模式的方法；
        context.fillStyle = pattern:绘制用特定模式填充的矩形；
    使用图像数据：
        getImageData(画面区域的x坐标,画面区域的y坐标,画面区域宽度,画面区域高度)方法：获取原始图像数据；  
            此方法返回的对象是ImageData的实例，每个ImageData对象都有三个属性：width、height、data;data属性是一个数组，保存着图像中每一个像素的数据。在data数组中，每一个像素用4个元素来保存，分别表示红、绿、蓝和透明度值。因此，第一个像素的数据就保存在数组的第0到第3个元素中；
        putImageData(imageData,画布区域的x坐标,画布区域的x坐标) ：把图像数据绘制到画布上；
    合成：
        globalAlpha属性:用指定所绘制的透明度，此值介于0-1之间；
        globalCompositionOperation属性：表示后绘制的图形怎样与先绘制的图形结合；
            source-over:默认值，后绘制的图形位于先绘制的图形上方；
            source-in:后绘制的图形与先绘制的图形重叠的部分可见，两者其他部分完全透明；
            source-out:后绘制的图形与先绘制的图形不重叠的部分可见，先绘制的图形完全透明；
            source-atop:后绘制的图形与先绘制的图形重叠的部分可见，先绘制的图形不受影响；
            destination-over:后绘制的图形位于先绘制的图形下方，只有之前透明像素下的部分才可见；
            destination-in:后绘制的图形位于先绘制的图形下方，两者不重叠的部分完全透明；
            destination-out:后绘制的图形擦除与先绘制的图形重叠的部分；
            destination-atop:后绘制的图形位于先绘制的图形下方，在两者不重叠的地方，先绘制的图形会变透明；
            lighter:后绘制的图形与先绘制的图形重叠部分的值相加，使该部分变亮；
            copy:后绘制的图形完全替代与之重叠的先绘制图形；
            xor:后绘制的图形与先绘制的图形重叠的部分执行“异或”操作；
    WebGL:是针对Canvas的3D上下文，主要用于3D游戏开发方面；这是一个比较大且涉及到较复杂的数学计算的领域，自己暂时用不到这方面，并且现在浏览器对这块的支持也不太完善，所以就先不研究他了，以后如果有这方面的需要在学习它；
    <h4>第16章：HTML5脚本编程</h4>
    跨文档信息传递：简称XDM,指的是在来自不同域的页面间传递信息；
    postMessage(“一条消息”,“消息接收方来自哪个域的字符串”)方法；
        是XDM的核心，把消息发送到特定域中的页面里；如果第二个域的参数是“*”，则会把消息发送给来自任何域的文档；
        接收到XDM消息时，会触发window对象的message事件；message事件的事件对象包含以下三个方面的重要信息；
            data:作为postMessage()第一个参数传入的字符串数据；
            origin:发送消息的文档所在的域；
            source:发送消息的文档的window对象的代理；
    拖放事件：
        作用于被拖放元素；
            dragstart:拖放开始事件；
            drag:拖放持续事件；
            dragend:拖放结束事件；
        作用于目标元素：
            dragenter:拖放进入事件；
            dragover:拖放在目标元素上持续事件；
            dragleave:拖放离开目标元素事件；
            drop:拖放释放在目标元素事件；
        dataTransfer对象：用于在进行拖放操作时实现数据的交换，是拖拽事件对象event的属性；此对象有两个方法：任何类型的参数都行；
            getData("text"/"url"):;
            setData("text"/"url","text"/"域名"):;
            dropEffect属性：被放置元素能够执行哪种放置行为；此属性需要在ondragenter事件处理程序针对放置目标来设置他；
                "none"：不能把拖动元素放在这里；
                "move":应该把拖动的元素移动到放置目标；
                “copy":应该把拖动的元素复制到放置目标；
                “link”：表示放置目标会打开拖动的元素；
            effectAllowed属性表示允许拖动元素的哪种dropEffect：此属性必须在ondragstart事件处理程序中设置；
                “uninitialized”：没有给被拖动的元素设置任何放置行为；
                “none”：被拖动的元素不能有任何行为；
                “copy”:只允许值为“copy”的dropEffect;
                “link”:只允许值为“link”的dropEffect;
                “move”:只允许值为“move”的dropEffect;
                “copyLink”:只允许值为“copy”和“link”的dropEffect;
                “copyMove”:只允许值为“copy”和“move”的dropEffect;
                "linkMove":只允许值为“link”和“move”的dropEffect;
                "all":允许任意dropEffect;
        draggable属性：设置被放置元素是否可拖动，为布尔值；
    媒体元素：
        属性：
            poster：指定图像的URL可以在加载视频内容期间显示一幅图像；
            controls：设置在标签中，则会在浏览器中显示UI控件，以便用户直接操作媒体；
            autoplay: 布尔值，自动播放设置；
            buffered:表示已下载的缓冲的时间范围的对象；
            bufferedBytes:表示已下载的缓冲的字节范围的对象；
            bufferingRate:下载过程中每秒钟平均接收的位数；
            bufferingThrottled:浏览器是否对缓冲进行了节流；
            currentLoop:媒体文件已经循环的次数；
            currentSrc:当前播放的媒体文件的URL;
            currentTime:已经播放的秒数；
            defaultPlaybackRate:默认的播放速度，默认值为1.0秒，开发人员可以改变这个值；
            duration:媒体的总播放时间秒数；
            ended:媒体文件是否播放完成；
            loop:是否设置为循环播放模式；
            muted:是否静音；
            networkState:表示当前媒体的网络连接状态：0表示空，1表示正在加载，2表示正在加载元数据，3表示已经加载了第一帧，4表示加载完成；
            paused:播放器是否暂停；
            playbackRate:当前的播放速度，用户可以改变这个值；
            played:到目前为止已经播放的时间范围；
            readyState:表示媒体是否已经就绪。0表示数据不可用，1表示可以显示当前帧，2表示可以开始播放，3表示媒体可以从头到尾播放；
            seekable:可以搜索的时间范围；
            seeking:表示播放器是否正移动到媒体文件的新位置；
            src:媒体文件的来源；
            start:取得或设置媒体文件中开始播放的位置，以秒计算；
            totalBytes:当前资源所需的总字节数；
            videoHeight:返回视频（不一定是元素）的高度；videoWidth:返回视频（不一定是元素）的宽度；
            volume:当前音量，值为0.0-1.0；
        事件：
            abort:下载中段；
            canplay:可以播放时；readyState值为2；
            canplaythrough：播放可继续，而且不会中断；readyState值为3;
            canshowcurrentframe:当前帧已经下载完成；readyState值为1；
            dataunavailable:因为没有数据而不能播放；readyState值为0；
            durationchange:duration属性的值改变；
            emptied:网络连接关闭；
            empty:发生错误阻止了媒体下载；
            ended:媒体已播放到末尾，播放停止；
            error:下载期间发生网路错误；
            load:所有媒体已经加载完成；此事件可能会被废除；
            loadeddata:媒体的第一帧已经加载完成；
            loadedmetadata:媒体的元数据已经加载完成；
            loadstart:下载已开始；
            pause:播放已暂停；
            play:媒体已经接收到指令开始播放；
            playing:媒体已经实际开始播放；
            progress:正在下载；
            ratechange:播放媒体的速度改变；
            seeked:搜索结束；
            seeking:正移动到新位置；
            stalled:浏览器尝试下载，但未接收到数据；
            timeupdate:currentTime被以不合理或意外的方式更新；
            volumechange:volume属性值或muted属性值已改变；
            waiting:播放暂停，等待下载更多数据；
        方法：
           play():播放；
           pause():暂停；
           canPlayType(“格式、编解码器字符串”):用以检测浏览器是否支持某种特定的文件格式和编解码器；返回“probably”、“maybe”或者空字符串；
        &ltaudio&gt元素还有一个原生的JavaScript构造函数Audio，可以在任何时候播放音频：如果想在一段音频播放后再播放另一段音频，必须在onfinish事件处理程序中调用play()方法；
           var audio = new Audio("sound.mp3");
        历史状态管理：
            history.pushState(状态对象，行状态标题，可选的相对URL):能够在不加载页面的情况下改变浏览器的URL;此时当点击后退按钮时会触发window对象的popstate事件；此事件的事件对象有一个state属性--pushState()的第一个参数；
            replaceState():更新当前状态的方法，传入的参数与pushState()的前两个参数相同。此方法不会在历史状态栈中创建新状态，只会重写当前状态；
    <h4>第十七章：错误处理与调试</h4>
    try-catch语句：处理异常的一种标准方式，能够让我们实现自己的错误处理机制；
        try{
           //可能会导致错误的代码
        } catch(error){
           //在错误发生时怎么处理
        } finally{
           //无论如何这里的代码都会执行
        }
            error是catch语块的对象名，此对象名有一个message属性
    错误类型对象：每种错误类型对象对应着相应类型的构造函数，构造函数并且可以接收一个作为抛出错误信息提示的
    自定义的参数；
        Error
        EvalError:会在使用eval()函数而发生错误异常时被抛出；
        RangeError：会在数值超出相应范围时触发；
        ReferenceError（引用错误）：在找不到对象的情况下会被抛出(或者访问不存在的变量时)；
        SyntaxError：在把语法错误的JavaScript字符串传入eval()函数时会导致此类错误；
        TypeError：在变量中保存着意外的类型时，或者在访问不存在的方法时，会出现此类错误；
        URLError：URI格式不正确会出现此类错误；
    抛出错误：
        throw操作符，用于随时抛出自定义错误；通常情况下代码遇到throw操作符会立即停止执行；但是在try-catch语句此操作符会继续执行代码；
    错误事件：
        任何没有通过try-catch处理的错误都会触发window对象的error事件；
    大体上来说，基本类型的值应该使用typeof来检测，而对象的值则应该使用instanceof来检测；
    可以把错误记录到服务器上；
    调试技术：
        console对象：向JavaScript控制台中写入消息；
            error(message):将错误信息记录到控制台；
            info(message):将信息性消息记录到控制台；
            log(message):将一般消息记录到控制台；
            warn(message):将警告信息记录到控制台；
    LiveConnect可以在JavaScript中运行Java代码；
    IE报错：
       操作终止修（operation aborted）：在修改该尚未加载完成的页面时，就会发生操作终止错误；
       无效字符（invalid character）：就是JavaScript中未定义的字符；
       未找到成员（Member not found）：如果对象被销毁之后又给该对象赋值，就会导致未找到成员错误；
       未知运行时错误（Unknown runtime erro）：当把块元素插入到行内元素是或者访问表格的任意部分的任意属性时；
       语法错误（syntax erro）：当引用了外部文件，而该文件没有返回相应的JavaScript代码时也会抛出语法错误，并且显示错误出现在第一行的第一个字符；
    这些调试器都支持设置断点，控制代码执行及在运行时检测变量的值；疑问P520
    <h4>第20章：JSON</h4>
    JSON:
        JavaScript Object Notation,JavaScript对象表示法；
        是JavaScript的一个严格的子集，利用JavaScript中的一些模式来表示结构化数据；
        它是一种数据格式，不是一种编程语言；
        并不是只有JavaScript才使用JSON，很多编程语言都针对JSON的解析器和序列化器；
        JSON不支持变量、函数或者对象实例；
    JSON的语法可以表示以下三种类型的值：
        简单值：使用与JavaScript相同的语法，可以在JSON中表示字符串、数值、布尔值、和null;但JSON不支持JavaScript中的特殊值undefined。
        对象：是一种复杂的数据类型；
            没有末尾的分号；
        数组：是一种复杂的数据类型；
            没有末尾的分号；
    JSON字符串必须使用双引号；JSON中的对象的属性必须加引号；
    解析和序列化：
        JSON数据结构解析为有用的JavaScript对象是受到广泛应用重要原因；
    早期的JSON解析器基本上就是使用JavaScript的eval()函数；
    ECMAScript 5对解析JSON的行为进行规范，定义了全局对象JSON;
    JSON对象有两个方法：
        stringify():
            把JavaScript对象序列化Json字符串；
            并且还可以接收另外两个参数:
                第一个参数是个过滤器，可以是一个数组或者函数；如果是数组则结果中将只包含数组中列出的属性； 如果是函数，则函数接收两个参数--键值对，可以通过这两个参数来控制操作要序列化的数据；
                第二个参数是一个表示是否在JSON字符串中保留字符串；如果是一个数值表示是每个级别缩进的空格数；如果是一个字符串则这个字符串中国被用作缩进字符；
            toJSON()方法：
                此方法是使用在JavaScript的对象内部，最为对函数过滤器的补充；
        parse():把JSON数据解析为原生JavaScript值；
            此方法也接受也接受一个相似的函数参数，叫做还原函数；
    <h4>第21章：Ajax 与 Comet</h4>
    Ajax是对Asynchronous JavaScript + XML 的简写；是一种无序刷新网页就可以获得服务器的数据的技术；
    Ajax技术的核心是XMLHttpRequest对象，简称XHR;
        var xhr = new XMLHttpRequest();
        xhr.open("get/post","URL",false/true):这行代码会启动一个针对特定URL文件的请求；open（）方法并不会真正发送请求，而只是启动一个请求以备发送；
        xhr.send(null):参数为请求主体发送的数据；
            readyState属性：该属性表示请求响应过程的当前活动阶段；此属性的每一次的变化都会触发readystatechange事件；但是必须在调用open()方法之前指定onreadystatechange事件处理程序才能确保跨浏览器兼容性；
                0：未初始化，尚未调用open（）方法；
                1：启动，已经调用open()方法，但尚未调用send()方法;
                2:发送，已经调用send()方法，但尚未接收到响应；
                3：接收，已经接受到部分响应数据；
                4：完成，已经接收到全部响应数据，而且已经可以在客户端使用了；
        XHR对象的属性：
            responseText:作为响应主体被返回的文本；
            responseXML:如果相应的内容类型是“text/xml”或者“application/xml”,这个属性中将保存着响应数据的XML DOM 文档；
            status:响应的HTTP状态；
                200：http请求返回成功；
                304：请求的资源并没有修改，可以直接使用浏览器中缓存的版本；
            statusText:HTTP状态说明；
        xhr.abort():在接受到响应之前取消异步操作；
    HTTP头部信息:
        Accept:浏览器能够处理的内容类型；
        Accept-Charset:浏览器能够显示的字符集；
        Accept-Encoding:浏览器能够处理的压缩编码；
        Accept-Language:浏览器当前设置的语言；
        Connection：浏览器与服务器之间连接的类型；
        Cookie:当前页面设置的任何Cookie;
        Host:发出请求的页面所在的域；
        Referer:发送请求的页面的URI;
        User-Agent:浏览器的用户代理字符串；
        setRequestHeader(头部字段，头部字段的值)方法：设置自定义的请求头部信息；要成功发送请求头部信息，必须在调用open()方法之后且在调用send()方法之前调用setRequestHeader();
        getRequestHeader(头部字段)方法：获取相应的响应头部信息；
        getAllRequestHeader()方法：获取所有的响应头部信息；
    var data = new FormData();
    data.append("key","value");
    var data = new FormData(document.forms[0]);
    超时设定：
        timeout属性：表示请求在等待相应多少毫秒之后就终止；如果在规定的超时时长之后没有相应就会触发ontimeout事件处理程序；
    进度事件：
        loadstart:在接收到响应数据的第一个字节时触发；
        progress:在接收响应期间持续不断的触发；
            会接受一个event对象；
                lengthComputable:是一个表示进度信息是否可用的布尔值；
                position:表示已经接受的字节数；
                totalSize:表示根据Content-Length响应头部确定的预期字节数；
        error:在请求发生错误时触发；
        abort:在因为调用abort()方法而终止连接时触发；
        load:在接收到完整的响应数据时触发；
        loaded:在通信完成或者error、abort或者load事件后触发；
    跨源资源共享：CORS(Cross-Origin Resource Sharing);P582
    Comet:
        是一种更高级的Ajax技术，也叫做“服务器推送”；
        Ajax是一种从页面向服务器请求数据的技术，Comet是一种服务器向页面推送的技术；
        有两种实现Comet的方式：
            长轮询：是短轮询的一个翻版；浏览器向服务器发送一个请求，并且一直保持连接打开，知道有数据可以发送再返回；发送完数据后浏览器关闭连接，随即又发起另一个到服务器的新请求；
                短轮询:浏览器定时向服务器发送请求，并及时的返回，看有没有信息可以返回；
            流：就是浏览器向服务器发送一个请求，而服务器保持连接打开，然后周期性的向浏览器发送数据；
    服务器发送事件：P590
    Web Sockets:P591
    </pre>
  </div>
</template>

<script>
export default {

}
</script>

<style scoped>
.detail-javascript-height{
  background-image: url(../assets/img/detailBg.jpg);
  padding:0.8rem 0.3rem;
  box-sizing: border-box;
}
pre{
  white-space: pre-wrap;
}
.title{
  text-align: center;
  padding-bottom: 0.3rem;
}
</style>
